<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Chanomic Sketch</title><link>https://bombrary.github.io/sketch/posts/</link><description>Recent content in Posts on Chanomic Sketch</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Sat, 10 Dec 2022 11:44:39 +0900</lastBuildDate><atom:link href="https://bombrary.github.io/sketch/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Colorful</title><link>https://bombrary.github.io/sketch/posts/colorful/</link><pubDate>Sat, 10 Dec 2022 11:44:39 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/colorful/</guid><description>別ページで閲覧 const alphabet = &amp;#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890&amp;#39;.split(&amp;#39;&amp;#39;); const rNum = 10; let textNumMin, textNumMax; let textSizeMin, textSizeMax; function setup() { cvs = createCanvas(windowWidth, windowHeight); palette = [&amp;#39;rgb(238,217,64)&amp;#39;, &amp;#39;rgb(229,100,37)&amp;#39;, &amp;#39;rgb(241,183,209)&amp;#39;, &amp;#39;rgb(163,221,231)&amp;#39;, &amp;#39;rgb(167, 202, 102)&amp;#39;].map((c) =&amp;gt; color(c)); background(255); const rMax = max(width/2, height/2); [textNumMin, textNumMax] = [rMax/2.5, rMax/1.5]; [textSizeMin, textSizeMax] = [rMax/30, rMax/10]; const rSep = rMax / rNum; for (let i = 0; i &amp;lt; rNum; i++) { if (i % 2 == 0) { const img = createGraphics(width, height); img.</description></item><item><title>Convergence</title><link>https://bombrary.github.io/sketch/posts/convergence/</link><pubDate>Fri, 09 Dec 2022 18:51:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/convergence/</guid><description>別ページで閲覧 const rectSep = 10; const rectNum = 40; const tileNum = 50; const tileSep = 2; function setup() { cvs = createCanvas(windowWidth, windowHeight); const palette1 = [&amp;#39;#E97777&amp;#39;, &amp;#39;#FF9F9F&amp;#39;, &amp;#39;#FFACC7&amp;#39;].map((c) =&amp;gt; color(c)); const palette2 = [&amp;#39;#FCDDB0&amp;#39;, &amp;#39;#FFFAD7&amp;#39;, &amp;#39;#FFB9B9&amp;#39;, &amp;#39;#FFDDD2&amp;#39;].map((c) =&amp;gt; color(c)); push(); drawingContext.shadowBlur = 10; drawingContext.shadowColor = &amp;#39;black&amp;#39;; const tileLen = width / tileNum; for (let i = 0; i &amp;lt; ceil(width/tileLen); i++) { for (let j = 0; j &amp;lt; ceil(height/tileLen); j++) { const x = (tileLen + tileSep) * i; const y = (tileLen + tileSep) * j; noStroke(); fill(random(palette2)); rect(x, y, tileLen, tileLen); } } pop(); background(255,255,255,64); const rectWidth = width / rectNum - rectSep; const img = createGraphics(width, height); for (let i = 0; i &amp;lt; rectNum; i++) { const x = (rectWidth + rectSep) * i; const t = i / rectNum; const rectHeight = 1.</description></item><item><title>Snow</title><link>https://bombrary.github.io/sketch/posts/snow/</link><pubDate>Thu, 08 Dec 2022 11:31:42 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/snow/</guid><description>別ページで閲覧 let cvs; let palette; const depthMax = 7; function setup() { cvs = createCanvas(windowWidth, windowHeight); palette = [&amp;#39;#CFF5E7&amp;#39;, &amp;#39;#A0E4CB&amp;#39;, &amp;#39;#59C1BD&amp;#39;, &amp;#39;#0D4C92&amp;#39;].map((c) =&amp;gt; color(c)); const bgColor = &amp;#39;#EFF5F5&amp;#39;; background(bgColor); noFill(); stroke(0); const L = min(width, height)/2; const img = createGraphics(width, height); img.translate(width/2, height/2); rec(img, createVector(0, -L/sqrt(3)), createVector(L/2, L/sqrt(3)/2), createVector(-L/2, L/sqrt(3)/2), 0); drawingContext.shadowBlur = 50; drawingContext.shadowColor = &amp;#39;gray&amp;#39;; drawingContext.shadowOffsetX = 10; drawingContext.shadowOffsetY = 10; image(img, 0, 0); } const rec = (img, p1, p2, p3, depth) =&amp;gt; { if (depth &amp;lt; depthMax) { img.</description></item><item><title>Planet</title><link>https://bombrary.github.io/sketch/posts/planet/</link><pubDate>Wed, 07 Dec 2022 10:10:27 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/planet/</guid><description>別ページで閲覧 let palette, cvs; let donutImgs; let RMax; const RNum = 5; const period = 40; function setup() { cvs = createCanvas(windowWidth, windowHeight); palette = [&amp;#39;#181D27&amp;#39;, &amp;#39;#254D32&amp;#39;, &amp;#39;#3A7D44&amp;#39;, &amp;#39;#69B578&amp;#39;, &amp;#39;#D0DB97&amp;#39;].map((c) =&amp;gt; color(c)); RMax = min(width, height) / 2; const rectLen = min(width, height) / 3 * 2; strokeWeight(10); noFill(); rectMode(CENTER); [rectLen*sqrt(2), rectLen, rectLen/3*2, rectLen/2].forEach((len) =&amp;gt; { stroke(lerpColor(palette[0], palette[2], random(0, 1))); rect(width / 2, height / 2, len, len); }); stroke(palette[2]); textAlign(CENTER, CENTER); textSize(100); text(&amp;#34;Hello&amp;#34;, width/2, height/2); const sep = Math.</description></item><item><title>Plant</title><link>https://bombrary.github.io/sketch/posts/plant/</link><pubDate>Tue, 06 Dec 2022 10:12:37 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/plant/</guid><description>別ページで閲覧 let tree, palette; const depthMax = 5; const flowerRadius = 7.5; const nodeMass = 1; const coefRestore = 0.01; const coefAir = 0.01; const windMax = 0.002; const windPeriod = 1000; const randomForceVar = 0.0005; let branchLenMean, branchLenStd; let branchAngleMean, branchAngleStd; function setup() { createCanvas(windowWidth, windowHeight); palette = [&amp;#39;#F4EAD5&amp;#39;, &amp;#39;#CCD6A6&amp;#39;, &amp;#39;#FF9E9E&amp;#39;].map((c) =&amp;gt; color(c)); [branchAngleMean, branchAngleStd] = [PI/6, 0.01]; [branchLenMean, branchLenStd] = [height / depthMax - (10 * depthMax), 20]; iterMax = height; tree = new Tree(createVector(0, -1), randomGaussian(branchLenMean, branchLenStd), 0, depthMax); } function draw() { background(palette[0]); const t = deltaTime * frameCount; const windX = windMax*sin(t/windPeriod); tree.</description></item><item><title>Glitchy Sun</title><link>https://bombrary.github.io/sketch/posts/glitchy-sun/</link><pubDate>Mon, 05 Dec 2022 11:27:30 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/glitchy-sun/</guid><description>別ページで閲覧 let palette, cvs; const [wMin, wMax] = [10, 500]; const [hMin, hMax] = [10, 500]; function setup() { palette = [&amp;#39;#E8F3D6&amp;#39;, &amp;#39;#FCF9BE&amp;#39;, &amp;#39;#FFDCA9&amp;#39;, &amp;#39;#FAAB78&amp;#39;].map((c) =&amp;gt; color(c)); cvs = createCanvas(windowWidth, windowHeight); background(palette[1]); const img = createGraphics(width, height); img.noStroke(); img.fill(palette[3]); img.circle(width / 2, height / 2, min(width, height)); blendMode(MULTIPLY); for (let i = 0; i &amp;lt; 50; i++) { const r = random(0, max(width, height)); const stAngle = random(0, TWO_PI); const enAngle = random(0, TWO_PI); const weight = random(0, 20); stroke(lerpColor(palette[1], palette[3], random())); strokeWeight(weight); noFill() arc(width / 4, height / 4, r, r, stAngle, enAngle); arc(3*width / 4, 3*height / 4, r, r, stAngle, enAngle); img.</description></item><item><title>Dance Room</title><link>https://bombrary.github.io/sketch/posts/dance-room/</link><pubDate>Sun, 04 Dec 2022 10:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/dance-room/</guid><description>別ページで閲覧 let cols; let N, M; let R, r; function setup() { createCanvas(windowWidth, windowHeight); cols = [color(&amp;#39;rgb(23, 10, 39)&amp;#39;), color(&amp;#39;rgb(111, 89, 163)&amp;#39;), color(&amp;#39;rgb(255, 255, 255)&amp;#39;)] frameRate(10); blendMode(BLEND); R = 50; r = 20; N = Math.floor(height / R); M = Math.floor(width / R); noiseDetail(8, 0.65); noStroke(); } function draw() { background(cols[0]); for (let i = 0; i &amp;lt; N; i++) { for (let j = 0; j &amp;lt; M; j++) { const [x, y] = hexCoordinate(i, j); const rate = noise(x, y, frameCount); colorMode(RGB); const col = lerpColor3(cols[0], cols[1], cols[2], rate); fill(col); const val = rate*20; colorMode(HSB, 360, 100, 100); drawingContext.</description></item><item><title>Night City</title><link>https://bombrary.github.io/sketch/posts/night-city/</link><pubDate>Sat, 03 Dec 2022 07:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/night-city/</guid><description>別ページで閲覧 const cols = [&amp;#39;#001F3F&amp;#39;, &amp;#39;#083358&amp;#39;, &amp;#39;#0D63A5&amp;#39;, &amp;#39;#FFD717&amp;#39;]; const colsRedundant = [...new Array(8).fill(cols[0]), ...new Array(4).fill(cols[1]), ...new Array(2).fill(cols[2]), ...new Array(1).fill(cols[3])]; const dt = 1; function setup() { createCanvas(windowWidth, windowHeight); background(cols[0]); noStroke(); for (let i = 0; i &amp;lt; 1000; i++) { const p1 = createVector(random(0, width), random(0, height)); const p2 = createVector(width / 2, height / 2); const vec = p5.Vector.sub(p2, p1).mult(random(0, 0.5)); band(p1, vec, abs(randomGaussian(0, 10))); } } const band = (pos, vec, w) =&amp;gt; { const norm = p5.</description></item><item><title>Sea of Characters</title><link>https://bombrary.github.io/sketch/posts/sea-of-characters/</link><pubDate>Fri, 02 Dec 2022 11:35:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/sea-of-characters/</guid><description>別ページで閲覧 let entities; const [fontSizeMin, fontSizeMax] = [0, 100]; const [rMin, rMax] = [0, 100]; const [textDxMin, textDxMax] = [-50, 50]; const [textDyMin, textDyMax] = [-1, 0]; const [circleDxMin, circleDxMax] = [-0.5, 0.5]; const [circleDyMin, circleDyMax] = [-1, 0]; function setup() { createCanvas(windowWidth, windowHeight); smooth(); entities = [...createTexts(20), ...createCircles(20)]; } function draw() { background(&amp;#39;#181B39&amp;#39;); for (const e of entities) { e.move(); e.draw(); } } const createCircles = (n) =&amp;gt; Array.</description></item><item><title>Circular Bars</title><link>https://bombrary.github.io/sketch/posts/circular-bars/</link><pubDate>Thu, 01 Dec 2022 11:25:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/circular-bars/</guid><description>別ページで閲覧 let r = 800; const dr = 100; const barMax = 100; const N = 400; let sep; function setup() { sep = TWO_PI / N; createCanvas(windowWidth, windowHeight); background(&amp;#39;#005b98&amp;#39;); } function draw() { translate(width / 2, height / 2); if (r &amp;lt;= 0) { noStroke(); fill(&amp;#39;white&amp;#39;); ellipse(0, 0, 2*dr, 2*dr); return; } const bars = createRandomBar(N, 0, barMax); let theta = 0; bars.forEach((bar) =&amp;gt; { fill(255); stroke(&amp;#39;orange&amp;#39;); drawBar(r, theta, sep, bar); theta += sep; }); r -= dr; } const drawBar = (r, theta, sep, bar) =&amp;gt; { const vs_polar = [ [r, theta], [r + bar, theta], [r + bar, theta + sep], [r, theta + sep], ] beginShape(); vs_polar.</description></item></channel></rss>