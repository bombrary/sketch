<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Chanomic Sketch</title><link>https://bombrary.github.io/sketch/posts/</link><description>Recent content in Posts on Chanomic Sketch</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Wed, 07 Dec 2022 10:10:27 +0900</lastBuildDate><atom:link href="https://bombrary.github.io/sketch/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Planet</title><link>https://bombrary.github.io/sketch/posts/planet/</link><pubDate>Wed, 07 Dec 2022 10:10:27 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/planet/</guid><description>別ページで閲覧 let palette, cvs; let donutImgs; let RMax; const RNum = 5; const period = 40; function setup() { cvs = createCanvas(windowWidth, windowHeight); palette = [&amp;#39;#181D27&amp;#39;, &amp;#39;#254D32&amp;#39;, &amp;#39;#3A7D44&amp;#39;, &amp;#39;#69B578&amp;#39;, &amp;#39;#D0DB97&amp;#39;].map((c) =&amp;gt; color(c)); RMax = min(width, height) / 2; const rectLen = min(width, height) / 3 * 2; strokeWeight(10); noFill(); rectMode(CENTER); [rectLen*sqrt(2), rectLen, rectLen/3*2, rectLen/2].forEach((len) =&amp;gt; { stroke(lerpColor(palette[0], palette[2], random(0, 1))); rect(width / 2, height / 2, len, len); }); stroke(palette[2]); textAlign(CENTER, CENTER); textSize(100); text(&amp;#34;Hello&amp;#34;, width/2, height/2); const sep = Math.</description></item><item><title>Plant</title><link>https://bombrary.github.io/sketch/posts/plant/</link><pubDate>Tue, 06 Dec 2022 10:12:37 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/plant/</guid><description>別ページで閲覧 let tree, palette; const depthMax = 5; const flowerRadius = 7.5; const nodeMass = 1; const coefRestore = 0.01; const coefAir = 0.01; const windMax = 0.002; const windPeriod = 1000; const randomForceVar = 0.0005; let branchLenMean, branchLenStd; let branchAngleMean, branchAngleStd; function setup() { createCanvas(windowWidth, windowHeight); palette = [&amp;#39;#F4EAD5&amp;#39;, &amp;#39;#CCD6A6&amp;#39;, &amp;#39;#FF9E9E&amp;#39;].map((c) =&amp;gt; color(c)); [branchAngleMean, branchAngleStd] = [PI/6, 0.01]; [branchLenMean, branchLenStd] = [height / depthMax - (10 * depthMax), 20]; iterMax = height; tree = new Tree(createVector(0, -1), randomGaussian(branchLenMean, branchLenStd), 0, depthMax); } function draw() { background(palette[0]); const t = deltaTime * frameCount; const windX = windMax*sin(t/windPeriod); tree.</description></item><item><title>Glitchy Sun</title><link>https://bombrary.github.io/sketch/posts/glitchy-sun/</link><pubDate>Mon, 05 Dec 2022 11:27:30 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/glitchy-sun/</guid><description>別ページで閲覧 let palette, cvs; const [wMin, wMax] = [10, 500]; const [hMin, hMax] = [10, 500]; function setup() { palette = [&amp;#39;#E8F3D6&amp;#39;, &amp;#39;#FCF9BE&amp;#39;, &amp;#39;#FFDCA9&amp;#39;, &amp;#39;#FAAB78&amp;#39;].map((c) =&amp;gt; color(c)); cvs = createCanvas(windowWidth, windowHeight); background(palette[1]); const img = createGraphics(width, height); img.noStroke(); img.fill(palette[3]); img.circle(width / 2, height / 2, min(width, height)); blendMode(MULTIPLY); for (let i = 0; i &amp;lt; 50; i++) { const r = random(0, max(width, height)); const stAngle = random(0, TWO_PI); const enAngle = random(0, TWO_PI); const weight = random(0, 20); stroke(lerpColor(palette[1], palette[3], random())); strokeWeight(weight); noFill() arc(width / 4, height / 4, r, r, stAngle, enAngle); arc(3*width / 4, 3*height / 4, r, r, stAngle, enAngle); img.</description></item><item><title>Dance Room</title><link>https://bombrary.github.io/sketch/posts/dance-room/</link><pubDate>Sun, 04 Dec 2022 10:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/dance-room/</guid><description>別ページで閲覧 let cols; let N, M; let R, r; function setup() { createCanvas(windowWidth, windowHeight); cols = [color(&amp;#39;rgb(23, 10, 39)&amp;#39;), color(&amp;#39;rgb(111, 89, 163)&amp;#39;), color(&amp;#39;rgb(255, 255, 255)&amp;#39;)] frameRate(10); blendMode(BLEND); R = 50; r = 20; N = Math.floor(height / R); M = Math.floor(width / R); noiseDetail(8, 0.65); noStroke(); } function draw() { background(cols[0]); for (let i = 0; i &amp;lt; N; i++) { for (let j = 0; j &amp;lt; M; j++) { const [x, y] = hexCoordinate(i, j); const rate = noise(x, y, frameCount); colorMode(RGB); const col = lerpColor3(cols[0], cols[1], cols[2], rate); fill(col); const val = rate*20; colorMode(HSB, 360, 100, 100); drawingContext.</description></item><item><title>Night City</title><link>https://bombrary.github.io/sketch/posts/night-city/</link><pubDate>Sat, 03 Dec 2022 07:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/night-city/</guid><description>別ページで閲覧 const cols = [&amp;#39;#001F3F&amp;#39;, &amp;#39;#083358&amp;#39;, &amp;#39;#0D63A5&amp;#39;, &amp;#39;#FFD717&amp;#39;]; const colsRedundant = [...new Array(8).fill(cols[0]), ...new Array(4).fill(cols[1]), ...new Array(2).fill(cols[2]), ...new Array(1).fill(cols[3])]; const dt = 1; function setup() { createCanvas(windowWidth, windowHeight); background(cols[0]); noStroke(); for (let i = 0; i &amp;lt; 1000; i++) { const p1 = createVector(random(0, width), random(0, height)); const p2 = createVector(width / 2, height / 2); const vec = p5.Vector.sub(p2, p1).mult(random(0, 0.5)); band(p1, vec, abs(randomGaussian(0, 10))); } } const band = (pos, vec, w) =&amp;gt; { const norm = p5.</description></item><item><title>Sea of Characters</title><link>https://bombrary.github.io/sketch/posts/sea-of-characters/</link><pubDate>Fri, 02 Dec 2022 11:35:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/sea-of-characters/</guid><description>別ページで閲覧 let entities; const [fontSizeMin, fontSizeMax] = [0, 100]; const [rMin, rMax] = [0, 100]; const [textDxMin, textDxMax] = [-50, 50]; const [textDyMin, textDyMax] = [-1, 0]; const [circleDxMin, circleDxMax] = [-0.5, 0.5]; const [circleDyMin, circleDyMax] = [-1, 0]; function setup() { createCanvas(windowWidth, windowHeight); smooth(); entities = [...createTexts(20), ...createCircles(20)]; } function draw() { background(&amp;#39;#181B39&amp;#39;); for (const e of entities) { e.move(); e.draw(); } } const createCircles = (n) =&amp;gt; Array.</description></item><item><title>Circular Bars</title><link>https://bombrary.github.io/sketch/posts/circular-bars/</link><pubDate>Thu, 01 Dec 2022 11:25:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/circular-bars/</guid><description>別ページで閲覧 let r = 800; const dr = 100; const barMax = 100; const N = 400; let sep; function setup() { sep = TWO_PI / N; createCanvas(windowWidth, windowHeight); background(&amp;#39;#005b98&amp;#39;); } function draw() { translate(width / 2, height / 2); if (r &amp;lt;= 0) { noStroke(); fill(&amp;#39;white&amp;#39;); ellipse(0, 0, 2*dr, 2*dr); return; } const bars = createRandomBar(N, 0, barMax); let theta = 0; bars.forEach((bar) =&amp;gt; { fill(255); stroke(&amp;#39;orange&amp;#39;); drawBar(r, theta, sep, bar); theta += sep; }); r -= dr; } const drawBar = (r, theta, sep, bar) =&amp;gt; { const vs_polar = [ [r, theta], [r + bar, theta], [r + bar, theta + sep], [r, theta + sep], ] beginShape(); vs_polar.</description></item></channel></rss>