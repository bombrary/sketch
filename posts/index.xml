<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Chanomic Sketch</title><link>https://bombrary.github.io/sketch/posts/</link><description>Recent content in Posts on Chanomic Sketch</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Fri, 30 Dec 2022 18:26:11 +0900</lastBuildDate><atom:link href="https://bombrary.github.io/sketch/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Sunset</title><link>https://bombrary.github.io/sketch/posts/sunset/</link><pubDate>Fri, 30 Dec 2022 18:26:11 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/sunset/</guid><description>別ページで閲覧 &amp;#34;use strict&amp;#34;; let palette; function setup() { createCanvas(windowWidth, windowHeight); palette = [&amp;#39;#DC3535&amp;#39;, &amp;#39;#212121&amp;#39;, &amp;#39;#000&amp;#39;, &amp;#39;#FFE15D&amp;#39;].map((c) =&amp;gt; color(c)); } function draw() { noLoop(); background(255); const t = frameCount / 50; const rate = (3 -sqrt(5))/2; noStroke(); const R0 = min(map(width, 0, 720, 0, 100), 100); const RMax = max(width, height) const rs = []; for (let r = R0; r &amp;lt; RMax; r += R0) { rs.push(r); } push(); translate(width/2, height*rate); for (let i = rs.</description></item><item><title>Fabric</title><link>https://bombrary.github.io/sketch/posts/fabric/</link><pubDate>Thu, 29 Dec 2022 19:04:54 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/fabric/</guid><description>別ページで閲覧 &amp;#34;use strict&amp;#34;; let palette, colBg; function setup() { pixelDensity(1); createCanvas(windowWidth, windowHeight); colBg = color(&amp;#39;#FCFFE7&amp;#39;); palette = [&amp;#39;#D2001A&amp;#39;, &amp;#39;#2B3467&amp;#39;, &amp;#39;#EF5B0C&amp;#39;].map((c) =&amp;gt; lerpColor(color(c), colBg, 0.25) ); } function draw() { noLoop(); background(colBg); translate(width/2, height/2); noStroke(255); let shapeNum = 3; const r0 = min(map(width, 0, 720, 0, 100), 100); const L = max(width, height); const rs = []; for (let r = r0; r &amp;lt; L; r += r0) { rs.push(r); } for (let i = 0; i &amp;lt; rs.</description></item><item><title>A Memory</title><link>https://bombrary.github.io/sketch/posts/a-memory/</link><pubDate>Wed, 28 Dec 2022 17:43:49 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/a-memory/</guid><description>別ページで閲覧 &amp;#34;use strict&amp;#34;; let colBg; let palette; let lineDrawer; let maskImg; let scrambleCount; function setup() { pixelDensity(1); createCanvas(windowWidth, windowHeight); const paletteBase = [&amp;#39;#61876E&amp;#39;, &amp;#39;#A6BB8D&amp;#39;, &amp;#39;#EAE7B1&amp;#39;].map((c) =&amp;gt; { const col = color(c); col.setAlpha(128); return col; }); palette = duplicate([5,1,1], paletteBase); colBg = color(&amp;#39;#3C6255&amp;#39;); scrambleCount = 3; maskImg = createGraphics(width, height); maskImg.fill(colBg); maskImg.noStroke(); drawHill(maskImg); lineDrawer = new LineDrawer(); background(colBg); fill(255, 192); noStroke(); drawCircles(width/8, width/2, 10); image(maskImg, 0, 0); } function draw() { lineDrawer.</description></item><item><title>Pop Circles</title><link>https://bombrary.github.io/sketch/posts/pop-circles/</link><pubDate>Tue, 27 Dec 2022 18:39:49 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/pop-circles/</guid><description>別ページで閲覧 &amp;#34;use strict&amp;#34;; const depthMax = 5; let palette; let xOff, yOff; let dx, dy; let R, r; function setup() { createCanvas(windowWidth, windowHeight); palette = [&amp;#39;#d92923&amp;#39;, &amp;#39;#005994&amp;#39;, &amp;#39;#e2d46c&amp;#39;].map((c) =&amp;gt; { const col = color(c); col.setAlpha(196); return col; }); xOff = 0; yOff = 0; R = map(width, 0, 720, 0, 80); r = map(width, 0, 720, 0, 10); dx = 3*R; dy = 3*R; } function draw() { drawEllipses(xOff, yOff, R, R, r, r, 12, 0); xOff += dx; if (xOff &amp;gt; 1.</description></item><item><title>Baloons</title><link>https://bombrary.github.io/sketch/posts/baloons/</link><pubDate>Mon, 26 Dec 2022 18:58:01 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/baloons/</guid><description>別ページで閲覧 &amp;#34;use strict&amp;#34;; let palette; function setup() { pixelDensity(1); createCanvas(windowWidth, windowHeight); background(0); // red, purple, yellow, green, blue palette = [&amp;#39;#FD8A8A&amp;#39;, &amp;#39;#BA94D1&amp;#39;, &amp;#39;#FFF89A&amp;#39;, &amp;#39;#B6E2A1&amp;#39;, &amp;#39;#9ADCFF&amp;#39;]; } function draw() { background(255); noLoop(); const H = min(map(height, 0, 820, 0, 100), 100); push(); translate(width/2, height/2); drawRectangle(width/2, H, 10); pop(); overlayNoise(); } const overlayNoise = () =&amp;gt; { loadPixels(); for (let x = 0; x &amp;lt; width; x++) { for (let y = 0; y &amp;lt; height; y++) { const i = (y * width + x) * 4; const dr = random(-20, 20); const dg = random(-20, 20); const db = random(-20, 20); if (pixels[i + 0] !</description></item><item><title>Present Box</title><link>https://bombrary.github.io/sketch/posts/present-box/</link><pubDate>Sun, 25 Dec 2022 18:57:22 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/present-box/</guid><description>別ページで閲覧 &amp;#34;use strict&amp;#34;; let palette; function setup() { createCanvas(windowWidth, windowHeight); background(0); palette = [&amp;#39;#DC3535&amp;#39;, &amp;#39;#FFE15D&amp;#39;, &amp;#39;#82CD47&amp;#39;, &amp;#39;#fff&amp;#39;].map((c) =&amp;gt; { const col = color(c); col.setAlpha(65); return col; }); } function draw() { background(0); noLoop(); const l = min(min(width, height), 720); const a = l/4; const b = l/4; const c = l/4; const cubicImg = createCuboidImg(50, a, b, c); const bgImg = createGrainImg(width, height, 50, 1, 100); image(bgImg, 0, 0); image(cubicImg, 0, 0); } const createCuboidImg = (N, a, b, c) =&amp;gt; { const img = createGraphics(width, height, WEBGL); const cam = img.</description></item><item><title>Merry Christmas</title><link>https://bombrary.github.io/sketch/posts/merry-christmas-2022/</link><pubDate>Sat, 24 Dec 2022 19:13:01 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/merry-christmas-2022/</guid><description>別ページで閲覧 &amp;#34;use strict&amp;#34;; let fgImg, bgImg; let starPalette; function setup() { pixelDensity(1); createCanvas(windowWidth, windowHeight); starPalette = [&amp;#39;#DC3535&amp;#39;, &amp;#39;#FFE15D&amp;#39;, &amp;#39;#82CD47&amp;#39;, &amp;#39;#fff&amp;#39;]; fgImg = createGraphics(width, height); bgImg = createGraphics(width, height); } function draw() { background(0); noLoop(); drawBg(100, 1, 15); image(bgImg, 0, 0); filter(BLUR, 1); drawFg(); image(fgImg, 0, 0); bgImg.clear(); drawBg(1000, 1, 5); image(bgImg, 0, 0); drawGrain(); } const drawFg = () =&amp;gt; { // Cone Top y_{i}: y_{i} = y_{i-1} + b r0 // Cone Rad r_{i}: r_{i} = a r_{i-1} // Cone Bottom h_{i}: h_{i} = y_{i} + r_{i} const a = 3/2; const b = 1/3; const N = 5; let y = 0; let r = calcR0(a, b, 0, N); const r0 = r; const ys = [y]; const rs = [r]; for (let i = 0; i &amp;lt;= N+1; i++) { y = y + r0/3; r *= a; ys.</description></item><item><title>Noisy Waves</title><link>https://bombrary.github.io/sketch/posts/noisy-waves/</link><pubDate>Fri, 23 Dec 2022 18:44:36 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/noisy-waves/</guid><description>別ページで閲覧 &amp;#34;use strict&amp;#34;; let palettes; let t; const waveNum = 5; function setup() { createCanvas(windowWidth, windowHeight); const palette1 = [&amp;#39;#49FF00&amp;#39;, &amp;#39;#FBFF00&amp;#39;, &amp;#39;#FF9300&amp;#39;, &amp;#39;#FF0000&amp;#39;]; const palette2 = [&amp;#39;#4D089A&amp;#39;, &amp;#39;#323EDD&amp;#39;, &amp;#39;#DC2ADE&amp;#39;, &amp;#39;#E8F044&amp;#39;]; const palette3 = [&amp;#39;#3FC5F0&amp;#39;, &amp;#39;#42DEE1&amp;#39;, &amp;#39;#6DECB9&amp;#39;, &amp;#39;#EEF5B2&amp;#39;]; const palette4 = [&amp;#39;#2EC1AC&amp;#39;, &amp;#39;#3E978B&amp;#39;, &amp;#39;#D2E603&amp;#39;, &amp;#39;#EFF48E&amp;#39;]; const palette5 = [&amp;#39;#8C0000&amp;#39;, &amp;#39;#BD2000&amp;#39;, &amp;#39;#FA1E0E&amp;#39;, &amp;#39;#FFBE0F&amp;#39;]; palettes = shuffle([palette1, palette2, palette3, palette4, palette5]); t = 0; background(0); } function draw() { const rad = height / (waveNum - 1) / 2; const waves = []; for (let i = 0; i &amp;lt; waveNum; i++) { const y = i * 2*rad; waves.</description></item><item><title>Circle Drops</title><link>https://bombrary.github.io/sketch/posts/circle-drops/</link><pubDate>Thu, 22 Dec 2022 17:35:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/circle-drops/</guid><description>別ページで閲覧 &amp;#34;use strict&amp;#34;; let maskImg, fgImg; const colorBg = &amp;#39;#242F9B&amp;#39;; const colorFg = &amp;#39;#F1F6F5&amp;#39;; let palette; let RMax; function setup() { createCanvas(windowWidth, windowHeight); maskImg = createGraphics(width, height); fgImg = createGraphics(width, height); palette = [&amp;#39;#242F9B&amp;#39;, &amp;#39;#82C3EC&amp;#39;].map((c) =&amp;gt; color(c)); RMax = width/10; } function draw() { background(&amp;#39;white&amp;#39;); const [isFound, x] = findX(); if (isFound) { // x1 ---- x ---- x2 const x1 = searchNeighborLineX(x, -1); const x2 = searchNeighborLineX(x, 1); const rMax = min(x - x1, x2 - x); const r = random(rMax/2, min(rMax, RMax)); const dy = 2*r + random(r/2, 2*r); drawShapesLine(x, dy, () =&amp;gt; { fgImg.</description></item><item><title>Wonderland</title><link>https://bombrary.github.io/sketch/posts/wonderland/</link><pubDate>Wed, 21 Dec 2022 19:36:41 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/wonderland/</guid><description>別ページで閲覧 &amp;#34;use strict&amp;#34;; const depthMax = 30; let R; function setup() { pixelDensity(1); createCanvas(windowWidth, windowHeight); colorMode(HSB); rectMode(CENTER); R = min(width/2, height/2); } function draw() { background(255); push(); translate(0, height); drawCircle(20); pop(); push(); translate(width, 0); rotate(PI); drawCircle(20); pop(); noLoop(); } const drawCircle = (rotNum) =&amp;gt; { for (let i = 0; i &amp;lt; rotNum; i++) { const sang = i / rotNum * TWO_PI/4 - TWO_PI/4; const eang = (i + 1) / rotNum * TWO_PI/4 - TWO_PI/4; const col = color(random(0, 360), 50, 100, 1); stroke(col); const mang = (i + 0.</description></item><item><title>Starfish</title><link>https://bombrary.github.io/sketch/posts/starfish/</link><pubDate>Tue, 20 Dec 2022 15:57:35 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/starfish/</guid><description>別ページで閲覧 Context FreeとかStructure Synthのような、再帰的な構造の生成に特化したソフトウェアなら、もっと簡潔に書けるはず。
&amp;#34;use strict&amp;#34;; const depthMax = 20; let palette; let rectLen, rectSep; function setup() { pixelDensity(1); createCanvas(windowWidth, windowHeight); palette = [&amp;#39;#DC3535&amp;#39;, &amp;#39;#FFE15D&amp;#39;, &amp;#39;#001253&amp;#39;].map((c) =&amp;gt; color(c)); rectLen = min(width, height) / depthMax * 1.1; rectSep = rectLen / 11; } function draw() { background(0); rectMode(CENTER); noStroke(); translate(width/2, height/2); const angles = Array.from({ length: 20 }).map((_, i) =&amp;gt; i / 20 * TWO_PI); shuffle(angles, true); for (let i = 0; i &amp;lt; 10; i++) { const x = random(-width/2, width/2); const y = random(-height/2, height/2); const cols = shuffle(palette); drawShapesAt(x, y, 0.</description></item><item><title>Gaussian City</title><link>https://bombrary.github.io/sketch/posts/gaussian-city/</link><pubDate>Mon, 19 Dec 2022 15:40:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/gaussian-city/</guid><description>別ページで閲覧 ガウス分布から2次元座標をサンプリングし，それをビル群に見立てた．ランダムな間隔で道路を引くことでより都市感が出せた．
&amp;#34;use strict&amp;#34;; let cam, img, boxLen; const board = []; const [nRow, nCol] = [50, 50]; let rotX, rotY, rotZ; const samplingNum = 10000; const variance = 4; function setup() { createCanvas(windowWidth, windowHeight, WEBGL); boxLen = min(min(width, height)/15, 50); for (let i = 0; i &amp;lt; nRow; i++) { board.push(Array.from({ length: nCol }).map(() =&amp;gt; 0)); } for (let i = 0; i &amp;lt; samplingNum; i++) { const x = randomGaussian(nCol/2, variance); const y = randomGaussian(nRow/2, variance); if (0 &amp;lt;= x &amp;amp;&amp;amp; x &amp;lt; nCol &amp;amp;&amp;amp; 0 &amp;lt;= y &amp;amp;&amp;amp; y &amp;lt; nRow) { board[floor(y)][floor(x)] += 0.</description></item><item><title>Crystal</title><link>https://bombrary.github.io/sketch/posts/crystal/</link><pubDate>Sun, 18 Dec 2022 20:18:27 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/crystal/</guid><description>別ページで閲覧 凸多角形の描画は以下のサイトを参考にした：Generating Random Convex Polygons．今回作ったコードでは，convexPolygonRandom関数が凸多角形の頂点を生成する役目を担っている．
let palette; const iterMax = 100; function setup() { createCanvas(windowWidth, windowHeight); palette = [&amp;#39;#332FD0&amp;#39;, &amp;#39;#C147E9&amp;#39;, &amp;#39;#00E7FF&amp;#39;].map((c) =&amp;gt; { const col = color(c); col.setAlpha(128); return col; }); background(0); } function draw() { for (let i = 0; i &amp;lt; iterMax; i++) { const x = random(0, width); const y = random(0, height); const [r, g, b, _] = get(x, y); const n = floor(random(3, 8)); if (r &amp;lt; 64 &amp;amp;&amp;amp; g &amp;lt; 64 &amp;amp;&amp;amp; b &amp;lt; 64) { drawPolygon(x, y, 100, 100, n); } } } const drawPolygon = (x, y, w, h, n) =&amp;gt; { const poly = convexPolygonRandom(n, w, h); const col = (() =&amp;gt; { const t = x / width + random(-0.</description></item><item><title>Vases</title><link>https://bombrary.github.io/sketch/posts/vases/</link><pubDate>Sat, 17 Dec 2022 21:23:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/vases/</guid><description>別ページで閲覧 const factor = 2; const maxXSep = 60; const maxNCols = 12; function setup() { createCanvas(windowWidth, windowHeight); const palette = [&amp;#39;#E14D2A&amp;#39;, &amp;#39;#FD841F&amp;#39;, &amp;#39;#3E6D9C&amp;#39;, &amp;#39;#001253&amp;#39;].map((c) =&amp;gt; { const col = color(c); col.setAlpha(64); return col; }) const xSep = min(width / maxNCols, maxXSep); const nCols = width / xSep; const ySep = xSep * factor; const nRows = ceil(height / ySep); const xRad = xSep / 2 * 0.5; const yRad = xRad/2; for (let i = 0; i &amp;lt; nRows; i++) { for (let j = 0; j &amp;lt; nCols; j++) { const x = j * xSep + xSep/2; const y = i * ySep + ySep/2; fill(random(palette)); const t1 = random(0, 1); const t2 = random(0, 1); drawShapeBroken(x, y, xRad, yRad, ySep - 2*yRad, t1, t2); } } } const drawShapeBroken = (x, y, xRad, yRad, h, t1, t2) =&amp;gt; { rectMode(CENTER); push(); translate(x, y); translate(0, -h/2); for (let i = 0; i &amp;lt; 10; i++) { drawingContext.</description></item><item><title>Random Koch Curve</title><link>https://bombrary.github.io/sketch/posts/random-koch-curve/</link><pubDate>Fri, 16 Dec 2022 22:23:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/random-koch-curve/</guid><description>別ページで閲覧 滲み感を出す練習 + コッホ曲線（をランダムにしたもの）の練習。
半透明の色を塗り重ねれば滲みを表現できることは、以下のサイトから学んだ： HOW TO HACK A PAINTING。 blendModeをいじってみると，重ね塗りの感じが変わって面白い。
const depthMax = 5; let curblendMode; let palette; let sel; function setup() { createCanvas(windowWidth, windowHeight); palette = [&amp;#39;#EB455F&amp;#39;, &amp;#39;#4B56D2&amp;#39;, &amp;#39;#FED049&amp;#39;].map((c) =&amp;gt; { const col = color(c); col.setAlpha(64); return col; }); sel = createSelect(); sel.position(10, 10); sel.option(&amp;#39;BLEND&amp;#39;); sel.option(&amp;#39;SCREEN&amp;#39;); sel.option(&amp;#39;SOFT_LIGHT&amp;#39;); sel.changed(() =&amp;gt; { const val = sel.value(); if (val === &amp;#39;BLEND&amp;#39;) curBlendMode = BLEND; else if (val === &amp;#39;SCREEN&amp;#39;) curBlendMode = SCREEN; else if (val === &amp;#39;SOFT_LIGHT&amp;#39;) curBlendMode = SOFT_LIGHT; else curBlendMode = BLEND; redraw(); }); curBlendMode = BLEND; redraw(); noLoop(); } function draw() { clear(); blendMode(curBlendMode); noStroke(); translate(0, height/2); push(); translate(width/4, 0); fill(palette[0]); for (let i = 0; i &amp;lt; 10; i++) { drawShape(50, 3); } fill(palette[1]); translate(width/4, 0); for (let i = 0; i &amp;lt; 10; i++) { drawShape(50, 4); } fill(palette[2]); translate(width/4, 0); for (let i = 0; i &amp;lt; 10; i++) { drawShape(50, 5); } pop(); } const drawShape = (radius, rotNum) =&amp;gt; { beginShape(); for (let i = 0; i &amp;lt; rotNum; i++) { const ang1 = TWO_PI/rotNum * i; const ang2 = TWO_PI/rotNum * (i + 1); const x1 = radius * cos(ang1); const y1 = radius * sin(ang1); const x2 = radius * cos(ang2); const y2 = radius * sin(ang2); rec(createVector(x1, y1), createVector(x2, y2), 0); } endShape(CLOSE); } // Koch curve-like drawing const rec = (pos1, pos2, depth) =&amp;gt; { if (depth &amp;gt;= depthMax) { return; } const vorig = p5.</description></item><item><title>Good Night</title><link>https://bombrary.github.io/sketch/posts/good-night/</link><pubDate>Thu, 15 Dec 2022 18:41:41 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/good-night/</guid><description>別ページで閲覧 const iterMax = 10; const brushMax = 100; const circleMax = 20; let circles; let yellowBrushes, blueBrushes; let yellowPalette, bluePalette; let layerBg, layerFg; function setup() { createCanvas(windowWidth, windowHeight); blendMode(BLEND); noStroke(); yellowPalette = [&amp;#39;#f8b12f&amp;#39;, &amp;#39;#fae690&amp;#39;, &amp;#39;#f7fae8&amp;#39;].map((c) =&amp;gt; color(c)); bluePalette = [&amp;#39;#211a3a&amp;#39;, &amp;#39;#22458e&amp;#39;, &amp;#39;#63beed&amp;#39;].map((c) =&amp;gt; color(c)); layerBg = createGraphics(width, height); layerFg = createGraphics(width, height); background(bluePalette[0]); blueBrushes = createBrushes(bluePalette, layerFg); yellowBrushes = createBrushes(yellowPalette, layerBg); circles = Array.from({ length: circleMax }) .map(() =&amp;gt; new Circle(random(0, width), random(0, height) ,random(10, 100))); } function draw() { for (let i = 0; i &amp;lt; iterMax; i++) { blueBrushes.</description></item><item><title>Chocolate Box</title><link>https://bombrary.github.io/sketch/posts/chocolate-box/</link><pubDate>Wed, 14 Dec 2022 16:58:38 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/chocolate-box/</guid><description>別ページで閲覧 let palette; const frameMax = 200; let frame = 0; function setup() { createCanvas(windowWidth, windowHeight); palette = [&amp;#39;#A77979&amp;#39;, &amp;#39;#553939&amp;#39;, &amp;#39;#704F4F&amp;#39;].map((c) =&amp;gt; color(c)); background(&amp;#39;#472D2D&amp;#39;); } function draw() { noStroke(); const rectNum = 5; const lenMax = min(width, height)/2; const rectLen = lenMax / rectNum; const xsp = (width - rectLen * rectNum * 2)/2; const ysp = (height - rectLen * rectNum * 2)/2; push(); stroke(&amp;#39;red&amp;#39;); pop(); if (frame &amp;lt; frameMax) { fillUp(xsp, ysp, rectNum, rectNum, rectLen, [1/2]); fillUp(xsp + rectNum*rectLen, ysp, rectNum, rectNum, rectLen, [1/3, 2/3]); fillUp(xsp, ysp + rectNum*rectLen, rectNum, rectNum, rectLen, [1/4, 2/4, 3/4]); fillUp(xsp + rectNum*rectLen, ysp + rectNum*rectLen, rectNum, rectNum, rectLen, [1/5, 2/5, 3/5, 4/5]); frame++; } else { noLoop(); } } const fillUp = (xstart, ystart, row, col, rectLen, ratioArr) =&amp;gt; { const w = rectLen; const h = rectLen; for (let i = 0; i &amp;lt; row; i++) { for (let j = 0; j &amp;lt; col; j++) { const x = xstart + j * rectLen; const y = ystart + i * rectLen; const [t0, t1, t2] = [random(ratioArr), random(ratioArr), random(ratioArr)]; const num = random(4); fill(randomColor(palette)); if (num &amp;lt; 1) { triangle(x + t0*w, y, x, y + t1*h, x + w, y + t2*h); } else if (num &amp;lt; 2) { triangle(x + t0*w, y, x, y + t1*h, x + t2*w, y + h); } else if (num &amp;lt; 3) { triangle(x + t0*w, y, x + w, y + t2*h, x + t2*w, y + h); } else { triangle(x + t2*w, y + h, x, y + t1*h, x + w, y + t2*h); } } } } const randomColor = (palette) =&amp;gt; { const t = random(palette.</description></item><item><title>A Blue Light</title><link>https://bombrary.github.io/sketch/posts/a-blue-light/</link><pubDate>Tue, 13 Dec 2022 12:52:14 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/a-blue-light/</guid><description>別ページで閲覧 let yellowPalette, bluePalette, bluePaletteRGB; let grainImg; let socket, light, code; let sizeScale; function setup() { createCanvas(windowWidth, windowHeight); yellowPalette = [&amp;#39;rgb(248,177,47)&amp;#39;, &amp;#39;rgb(250,230,144)&amp;#39;, &amp;#39;rgb(247,250,232)&amp;#39;].map((c) =&amp;gt; color(c)); bluePalette = [&amp;#39;rgb(33,26,58)&amp;#39;, &amp;#39;rgb(34,69,142)&amp;#39;, &amp;#39;rgb(99,190,237)&amp;#39;].map((c) =&amp;gt; color(c)); bluePaletteRGB = bluePalette.map((c) =&amp;gt; [red(c), green(c), blue(c)]); grainImg = generateGrainImg(); sizeScale = min(width, height)/150; socket = new Socket(sizeScale); light = new Light(sizeScale); code = new Code(5*sizeScale, 50*sizeScale, 5*sizeScale); } function draw() { background(bluePalette[0]); push(); translate(width/2, 0); push(); translate(0, code.</description></item><item><title>Toy Box</title><link>https://bombrary.github.io/sketch/posts/toy-box/</link><pubDate>Mon, 12 Dec 2022 20:09:07 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/toy-box/</guid><description> 別ページで閲覧 let palette; function setup() { createCanvas(windowWidth, windowHeight); palette = [&amp;#39;#FF9E9E&amp;#39;, &amp;#39;#F8F988&amp;#39;, &amp;#39;#C0EEE4&amp;#39;]; background(&amp;#39;#F9F9F9&amp;#39;); rec(0, 0, width, height, 0) } const rec = (x, y, w, h, depth) =&amp;gt; { if (w &amp;lt; width/10 || h &amp;lt; height/10) { noStroke(); fill(random(palette)); push(); translate(x, y); translate(-w/2, -h/2); rotate(random(-PI/90, PI/90)); translate(w/2, h/2); rect(0, 0, w, h); pop(); } else { const t = random(); if (random() &amp;lt; 0.5) { [newW, newH] = [t*w, h] rec(x + t*w, y, (1-t)*w, h, depth + 1); rec(x , y, t*w, h, depth + 1); } else { [newW, newH] = [w, t*h] rec(x, y + t*h, w, (1-t)*h, depth + 1); rec(x, y , w, t*h, depth + 1); } } }</description></item><item><title>Flicker</title><link>https://bombrary.github.io/sketch/posts/flicker/</link><pubDate>Sun, 11 Dec 2022 16:17:40 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/flicker/</guid><description>別ページで閲覧 let img, gridCircles; let lightColorBase; function setup() { createCanvas(windowWidth, windowHeight); img = noiseOverlay(); push(); colorMode(HSB); lightColorBase = color(&amp;#39;#FFFFD0&amp;#39;); pop(); const [N, M] = [3, 3]; const r = 10; const sep = 2; const [rectHeight, rectWidth] = [2*r*N, 2*r*M]; const rectSep = 40; const rectRowNum = ceil(height / (rectHeight + rectSep)); const rectColNum = ceil(width / (rectWidth + rectSep)); const rectNum = 30; const rectNumMax = rectRowNum * rectColNum; const indicies = choice(Array.</description></item><item><title>Colorful</title><link>https://bombrary.github.io/sketch/posts/colorful/</link><pubDate>Sat, 10 Dec 2022 11:44:39 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/colorful/</guid><description>別ページで閲覧 const alphabet = &amp;#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890&amp;#39;.split(&amp;#39;&amp;#39;); const rNum = 10; let textNumMin, textNumMax; let textSizeMin, textSizeMax; function setup() { createCanvas(windowWidth, windowHeight); palette = [&amp;#39;rgb(238,217,64)&amp;#39;, &amp;#39;rgb(229,100,37)&amp;#39;, &amp;#39;rgb(241,183,209)&amp;#39;, &amp;#39;rgb(163,221,231)&amp;#39;, &amp;#39;rgb(167, 202, 102)&amp;#39;].map((c) =&amp;gt; color(c)); background(255); const rMax = max(width/2, height/2); [textNumMin, textNumMax] = [rMax/2.5, rMax/1.5]; [textSizeMin, textSizeMax] = [rMax/30, rMax/10]; const rSep = rMax / rNum; for (let i = 0; i &amp;lt; rNum; i++) { if (i % 2 == 0) { const img = createGraphics(width, height); img.</description></item><item><title>Convergence</title><link>https://bombrary.github.io/sketch/posts/convergence/</link><pubDate>Fri, 09 Dec 2022 18:51:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/convergence/</guid><description>別ページで閲覧 const rectSep = 10; const rectNum = 40; const tileNum = 50; const tileSep = 2; function setup() { cvs = createCanvas(windowWidth, windowHeight); const palette1 = [&amp;#39;#E97777&amp;#39;, &amp;#39;#FF9F9F&amp;#39;, &amp;#39;#FFACC7&amp;#39;].map((c) =&amp;gt; color(c)); const palette2 = [&amp;#39;#FCDDB0&amp;#39;, &amp;#39;#FFFAD7&amp;#39;, &amp;#39;#FFB9B9&amp;#39;, &amp;#39;#FFDDD2&amp;#39;].map((c) =&amp;gt; color(c)); push(); drawingContext.shadowBlur = 10; drawingContext.shadowColor = &amp;#39;black&amp;#39;; const tileLen = width / tileNum; for (let i = 0; i &amp;lt; ceil(width/tileLen); i++) { for (let j = 0; j &amp;lt; ceil(height/tileLen); j++) { const x = (tileLen + tileSep) * i; const y = (tileLen + tileSep) * j; noStroke(); fill(random(palette2)); rect(x, y, tileLen, tileLen); } } pop(); background(255,255,255,64); const rectWidth = width / rectNum - rectSep; const img = createGraphics(width, height); for (let i = 0; i &amp;lt; rectNum; i++) { const x = (rectWidth + rectSep) * i; const t = i / rectNum; const rectHeight = 1.</description></item><item><title>Snow</title><link>https://bombrary.github.io/sketch/posts/snow/</link><pubDate>Thu, 08 Dec 2022 11:31:42 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/snow/</guid><description>別ページで閲覧 let cvs; let palette; const depthMax = 7; function setup() { cvs = createCanvas(windowWidth, windowHeight); palette = [&amp;#39;#CFF5E7&amp;#39;, &amp;#39;#A0E4CB&amp;#39;, &amp;#39;#59C1BD&amp;#39;, &amp;#39;#0D4C92&amp;#39;].map((c) =&amp;gt; color(c)); const bgColor = &amp;#39;#EFF5F5&amp;#39;; background(bgColor); noFill(); stroke(0); const L = min(width, height)/2; const img = createGraphics(width, height); img.translate(width/2, height/2); rec(img, createVector(0, -L/sqrt(3)), createVector(L/2, L/sqrt(3)/2), createVector(-L/2, L/sqrt(3)/2), 0); drawingContext.shadowBlur = 50; drawingContext.shadowColor = &amp;#39;gray&amp;#39;; drawingContext.shadowOffsetX = 10; drawingContext.shadowOffsetY = 10; image(img, 0, 0); } const rec = (img, p1, p2, p3, depth) =&amp;gt; { if (depth &amp;lt; depthMax) { img.</description></item><item><title>Planet</title><link>https://bombrary.github.io/sketch/posts/planet/</link><pubDate>Wed, 07 Dec 2022 10:10:27 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/planet/</guid><description>別ページで閲覧 let palette, cvs; let donutImgs; let RMax; const RNum = 5; const period = 40; function setup() { cvs = createCanvas(windowWidth, windowHeight); palette = [&amp;#39;#181D27&amp;#39;, &amp;#39;#254D32&amp;#39;, &amp;#39;#3A7D44&amp;#39;, &amp;#39;#69B578&amp;#39;, &amp;#39;#D0DB97&amp;#39;].map((c) =&amp;gt; color(c)); RMax = min(width, height) / 2; const rectLen = min(width, height) / 3 * 2; strokeWeight(10); noFill(); rectMode(CENTER); [rectLen*sqrt(2), rectLen, rectLen/3*2, rectLen/2].forEach((len) =&amp;gt; { stroke(lerpColor(palette[0], palette[2], random(0, 1))); rect(width / 2, height / 2, len, len); }); stroke(palette[2]); textAlign(CENTER, CENTER); textSize(100); text(&amp;#34;Hello&amp;#34;, width/2, height/2); const sep = Math.</description></item><item><title>Plant</title><link>https://bombrary.github.io/sketch/posts/plant/</link><pubDate>Tue, 06 Dec 2022 10:12:37 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/plant/</guid><description>別ページで閲覧 let tree, palette; const depthMax = 5; const flowerRadius = 7.5; const nodeMass = 1; const coefRestore = 0.01; const coefAir = 0.01; const windMax = 0.002; const windPeriod = 1000; const randomForceVar = 0.0005; let branchLenMean, branchLenStd; let branchAngleMean, branchAngleStd; function setup() { createCanvas(windowWidth, windowHeight); palette = [&amp;#39;#F4EAD5&amp;#39;, &amp;#39;#CCD6A6&amp;#39;, &amp;#39;#FF9E9E&amp;#39;].map((c) =&amp;gt; color(c)); [branchAngleMean, branchAngleStd] = [PI/6, 0.01]; [branchLenMean, branchLenStd] = [height / depthMax - (10 * depthMax), 20]; iterMax = height; tree = new Tree(createVector(0, -1), randomGaussian(branchLenMean, branchLenStd), 0, depthMax); } function draw() { background(palette[0]); const t = deltaTime * frameCount; const windX = windMax*sin(t/windPeriod); tree.</description></item><item><title>Glitchy Sun</title><link>https://bombrary.github.io/sketch/posts/glitchy-sun/</link><pubDate>Mon, 05 Dec 2022 11:27:30 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/glitchy-sun/</guid><description>別ページで閲覧 let palette, cvs; const [wMin, wMax] = [10, 500]; const [hMin, hMax] = [10, 500]; function setup() { palette = [&amp;#39;#E8F3D6&amp;#39;, &amp;#39;#FCF9BE&amp;#39;, &amp;#39;#FFDCA9&amp;#39;, &amp;#39;#FAAB78&amp;#39;].map((c) =&amp;gt; color(c)); cvs = createCanvas(windowWidth, windowHeight); background(palette[1]); const img = createGraphics(width, height); img.noStroke(); img.fill(palette[3]); img.circle(width / 2, height / 2, min(width, height)); blendMode(MULTIPLY); for (let i = 0; i &amp;lt; 50; i++) { const r = random(0, max(width, height)); const stAngle = random(0, TWO_PI); const enAngle = random(0, TWO_PI); const weight = random(0, 20); stroke(lerpColor(palette[1], palette[3], random())); strokeWeight(weight); noFill() arc(width / 4, height / 4, r, r, stAngle, enAngle); arc(3*width / 4, 3*height / 4, r, r, stAngle, enAngle); img.</description></item><item><title>Dance Room</title><link>https://bombrary.github.io/sketch/posts/dance-room/</link><pubDate>Sun, 04 Dec 2022 10:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/dance-room/</guid><description>別ページで閲覧 let cols; let N, M; let R, r; function setup() { createCanvas(windowWidth, windowHeight); cols = [color(&amp;#39;rgb(23, 10, 39)&amp;#39;), color(&amp;#39;rgb(111, 89, 163)&amp;#39;), color(&amp;#39;rgb(255, 255, 255)&amp;#39;)] frameRate(10); blendMode(BLEND); R = 50; r = 20; N = Math.floor(height / R); M = Math.floor(width / R); noiseDetail(8, 0.65); noStroke(); } function draw() { background(cols[0]); for (let i = 0; i &amp;lt; N; i++) { for (let j = 0; j &amp;lt; M; j++) { const [x, y] = hexCoordinate(i, j); const rate = noise(x, y, frameCount); colorMode(RGB); const col = lerpColor3(cols[0], cols[1], cols[2], rate); fill(col); const val = rate*20; colorMode(HSB, 360, 100, 100); drawingContext.</description></item><item><title>Night City</title><link>https://bombrary.github.io/sketch/posts/night-city/</link><pubDate>Sat, 03 Dec 2022 07:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/night-city/</guid><description>別ページで閲覧 const cols = [&amp;#39;#001F3F&amp;#39;, &amp;#39;#083358&amp;#39;, &amp;#39;#0D63A5&amp;#39;, &amp;#39;#FFD717&amp;#39;]; const colsRedundant = [...new Array(8).fill(cols[0]), ...new Array(4).fill(cols[1]), ...new Array(2).fill(cols[2]), ...new Array(1).fill(cols[3])]; const dt = 1; function setup() { createCanvas(windowWidth, windowHeight); background(cols[0]); noStroke(); for (let i = 0; i &amp;lt; 1000; i++) { const p1 = createVector(random(0, width), random(0, height)); const p2 = createVector(width / 2, height / 2); const vec = p5.Vector.sub(p2, p1).mult(random(0, 0.5)); band(p1, vec, abs(randomGaussian(0, 10))); } } const band = (pos, vec, w) =&amp;gt; { const norm = p5.</description></item><item><title>Sea of Characters</title><link>https://bombrary.github.io/sketch/posts/sea-of-characters/</link><pubDate>Fri, 02 Dec 2022 11:35:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/sea-of-characters/</guid><description>別ページで閲覧 let entities; const [fontSizeMin, fontSizeMax] = [0, 100]; const [rMin, rMax] = [0, 100]; const [textDxMin, textDxMax] = [-50, 50]; const [textDyMin, textDyMax] = [-1, 0]; const [circleDxMin, circleDxMax] = [-0.5, 0.5]; const [circleDyMin, circleDyMax] = [-1, 0]; function setup() { createCanvas(windowWidth, windowHeight); smooth(); entities = [...createTexts(20), ...createCircles(20)]; } function draw() { background(&amp;#39;#181B39&amp;#39;); for (const e of entities) { e.move(); e.draw(); } } const createCircles = (n) =&amp;gt; Array.</description></item><item><title>Circular Bars</title><link>https://bombrary.github.io/sketch/posts/circular-bars/</link><pubDate>Thu, 01 Dec 2022 11:25:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/circular-bars/</guid><description>別ページで閲覧 let r = 800; const dr = 100; const barMax = 100; const N = 400; let sep; function setup() { sep = TWO_PI / N; createCanvas(windowWidth, windowHeight); background(&amp;#39;#005b98&amp;#39;); } function draw() { translate(width / 2, height / 2); if (r &amp;lt;= 0) { noStroke(); fill(&amp;#39;white&amp;#39;); ellipse(0, 0, 2*dr, 2*dr); return; } const bars = createRandomBar(N, 0, barMax); let theta = 0; bars.forEach((bar) =&amp;gt; { fill(255); stroke(&amp;#39;orange&amp;#39;); drawBar(r, theta, sep, bar); theta += sep; }); r -= dr; } const drawBar = (r, theta, sep, bar) =&amp;gt; { const vs_polar = [ [r, theta], [r + bar, theta], [r + bar, theta + sep], [r, theta + sep], ] beginShape(); vs_polar.</description></item></channel></rss>