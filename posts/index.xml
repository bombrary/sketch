<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Chanomic Sketch</title><link>https://bombrary.github.io/sketch/posts/</link><description>Recent content in Posts on Chanomic Sketch</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Fri, 27 Dec 2024 23:00:00 +0900</lastBuildDate><atom:link href="https://bombrary.github.io/sketch/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Reversed Stripe</title><link>https://bombrary.github.io/sketch/posts/reversed-stripe/</link><pubDate>Fri, 27 Dec 2024 23:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/reversed-stripe/</guid><description>別ページで閲覧 const vs = ` attribute vec3 aPosition; attribute vec2 aTexCoord; varying vec2 vTexCoord; void main() { vec4 positionVec4 = vec4(aPosition, 1.0); positionVec4.xy = positionVec4.xy * 2.0 - 1.0; gl_Position = positionVec4; vTexCoord = aTexCoord; } `; const fs = ` #ifdef GL_ES precision mediump float; #endif varying vec2 vTexCoord; uniform sampler2D uTex; uniform float uPhi; uniform vec2 uCenter; uniform float uPi; void main() { vec2 uv = vTexCoord; uv.</description></item><item><title>Stripe</title><link>https://bombrary.github.io/sketch/posts/stripe/</link><pubDate>Thu, 26 Dec 2024 23:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/stripe/</guid><description>別ページで閲覧 const vs = ` attribute vec3 aPosition; attribute vec2 aTexCoord; varying vec2 vTexCoord; void main() { vec4 positionVec4 = vec4(aPosition, 1.0); positionVec4.xy = positionVec4.xy * 2.0 - 1.0; gl_Position = positionVec4; vTexCoord = aTexCoord; } `; const fs = ` #ifdef GL_ES precision mediump float; #endif varying vec2 vTexCoord; uniform sampler2D uTex; uniform float uPhi; uniform vec2 uCenter; uniform float uPi; void main() { vec2 uv = vTexCoord; uv.</description></item><item><title>Silent Night</title><link>https://bombrary.github.io/sketch/posts/silent-night/</link><pubDate>Wed, 25 Dec 2024 19:20:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/silent-night/</guid><description>別ページで閲覧 const vs = ` attribute vec3 aPosition; attribute vec2 aTexCoord; varying vec2 vTexCoord; void main() { vec4 positionVec4 = vec4(aPosition, 1.0); positionVec4.xy = positionVec4.xy * 2.0 - 1.0; gl_Position = positionVec4; vTexCoord = aTexCoord; } `; const fs = ` #ifdef GL_ES precision mediump float; #endif varying vec2 vTexCoord; uniform sampler2D uTex; uniform float uPhi; uniform vec2 uCenter; uniform float uPi; void main() { vec2 uv = vTexCoord; uv.</description></item><item><title>Holy Night</title><link>https://bombrary.github.io/sketch/posts/holy-night/</link><pubDate>Tue, 24 Dec 2024 22:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/holy-night/</guid><description>別ページで閲覧 const vs = ` attribute vec3 aPosition; attribute vec2 aTexCoord; varying vec2 vTexCoord; void main() { vec4 positionVec4 = vec4(aPosition, 1.0); positionVec4.xy = positionVec4.xy * 2.0 - 1.0; gl_Position = positionVec4; vTexCoord = aTexCoord; } `; const fs = ` #ifdef GL_ES precision mediump float; #endif varying vec2 vTexCoord; uniform sampler2D uTex; uniform float uPhi; uniform vec2 uCenter; uniform float uPi; void main() { vec2 uv = vTexCoord; uv.</description></item><item><title>Shooting Star</title><link>https://bombrary.github.io/sketch/posts/shooting-star/</link><pubDate>Mon, 23 Dec 2024 06:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/shooting-star/</guid><description>別ページで閲覧 const vs = ` attribute vec3 aPosition; attribute vec2 aTexCoord; varying vec2 vTexCoord; void main() { vec4 positionVec4 = vec4(aPosition, 1.0); positionVec4.xy = positionVec4.xy * 2.0 - 1.0; gl_Position = positionVec4; vTexCoord = aTexCoord; } `; const fs = ` #ifdef GL_ES precision mediump float; #endif varying vec2 vTexCoord; uniform sampler2D uTex; uniform float uPhi; uniform vec2 uCenter; uniform float uPi; void main() { vec2 uv = vTexCoord; uv.</description></item><item><title>Riven with Wood</title><link>https://bombrary.github.io/sketch/posts/riven-with-wood/</link><pubDate>Sun, 22 Dec 2024 17:54:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/riven-with-wood/</guid><description>別ページで閲覧 個人的お気に入り作品 Solitude をベースに作成。
const vs = ` attribute vec3 aPosition; attribute vec2 aTexCoord; varying vec2 vTexCoord; void main() { vec4 positionVec4 = vec4(aPosition, 1.0); positionVec4.xy = positionVec4.xy * 2.0 - 1.0; gl_Position = positionVec4; vTexCoord = aTexCoord; } `; const fs = ` #ifdef GL_ES precision mediump float; #endif varying vec2 vTexCoord; uniform sampler2D uTex; uniform float uPhi; uniform vec2 uCenter; uniform float uPi; void main() { vec2 uv = vTexCoord; uv.</description></item><item><title>Riven</title><link>https://bombrary.github.io/sketch/posts/riven/</link><pubDate>Sat, 21 Dec 2024 15:20:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/riven/</guid><description>別ページで閲覧 const PHI = 1.6180339; let yellowCol; let palette0; function setup() { createCanvas(windowWidth, windowHeight); yellowCol = color(&amp;#39;#FFF574&amp;#39;); palette0 = [&amp;#39;#343131&amp;#39;, &amp;#39;#A04747&amp;#39;, &amp;#39;#D8A25E&amp;#39;, &amp;#39;#E85C0D&amp;#39;].map((c) =&amp;gt; color(c)); } function draw() { const mainImg = drawMain(); const overlayImg = drawOverlay(); image(mainImg, 0, 0); image(overlayImg, 0, 0); const grain = generateGrainImg(-255, 255); image(grain, 0, 0); noLoop(); } function drawMain() { const img = createGraphics(width, height); img.noStroke(); drawBackground(img); drawCloud(img); drawMoon(img); return img; } function drawBackground(img) { img.</description></item><item><title>Targets</title><link>https://bombrary.github.io/sketch/posts/targets/</link><pubDate>Fri, 20 Dec 2024 21:55:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/targets/</guid><description>別ページで閲覧 const PHI = 1.6180339; let yellowCol; let palette0; let palette1; let palette2; function setup() { createCanvas(windowWidth, windowHeight); palette0 = [&amp;#39;#DCE4C9&amp;#39;, &amp;#39;#F5F5DC&amp;#39;, &amp;#39;#B6A28E&amp;#39;, &amp;#39;#E07B39&amp;#39;].map((c) =&amp;gt; color(c)); palette1 = [&amp;#39;#FF76CE&amp;#39;, &amp;#39;#FDFFC2&amp;#39;, &amp;#39;#94FFD8&amp;#39;, &amp;#39;#A3D8FF&amp;#39;].map((c) =&amp;gt; color(c)); palette2 = [&amp;#39;#432E54&amp;#39;, &amp;#39;#4B4376&amp;#39;, &amp;#39;#AE445A&amp;#39;, &amp;#39;#E8BCB9&amp;#39;].map((c) =&amp;gt; color(c)); } function draw() { const mainImg = drawMain(); const overlayImg = drawOverlay(); image(mainImg, 0, 0); image(overlayImg, 0, 0); const grain = generateGrainImg(-255, 255); image(grain, 0, 0); noLoop(); } function drawMain() { const img = createGraphics(width, height); drawBackground(img); drawCloud(img); drawMoon(img); return img; } function drawBackground(img) { img.</description></item><item><title>Mosaic World</title><link>https://bombrary.github.io/sketch/posts/mosaic-world/</link><pubDate>Thu, 19 Dec 2024 16:35:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/mosaic-world/</guid><description>別ページで閲覧 const PHI = 1.6180339; let yellowCol; let palette0; let palette1; let palette2; function setup() { createCanvas(windowWidth, windowHeight); palette0 = [&amp;#39;#BFECFF&amp;#39;, &amp;#39;#CDC1FF&amp;#39;, &amp;#39;#FFF6E3&amp;#39;, &amp;#39;#FFCCEA&amp;#39;].map((c) =&amp;gt; color(c)); palette1 = [&amp;#39;#FF76CE&amp;#39;, &amp;#39;#FDFFC2&amp;#39;, &amp;#39;#94FFD8&amp;#39;, &amp;#39;#A3D8FF&amp;#39;].map((c) =&amp;gt; color(c)); palette2 = [&amp;#39;#F6D6D6&amp;#39;, &amp;#39;#F6F7C4&amp;#39;, &amp;#39;#A1EEBD&amp;#39;, &amp;#39;#7BD3EA&amp;#39;].map((c) =&amp;gt; color(c)); } function draw() { const mainImg = drawMain(); const overlayImg = drawOverlay(); image(mainImg, 0, 0); image(overlayImg, 0, 0); const grain = generateGrainImg(-255, 255); image(grain, 0, 0); noLoop(); } function drawMain() { const img = createGraphics(width, height); img.</description></item><item><title>Mysterious Night</title><link>https://bombrary.github.io/sketch/posts/mysterious-night/</link><pubDate>Wed, 18 Dec 2024 16:30:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/mysterious-night/</guid><description>別ページで閲覧 const PHI = 1.6180339; let yellowCol; let yellowPalette; function setup() { createCanvas(windowWidth, windowHeight); yellowPalette = [&amp;#39;#0B8494&amp;#39;, &amp;#39;#125B9A&amp;#39;, &amp;#39;#F05A7E&amp;#39;, &amp;#39;#FFBE98&amp;#39;].map((c) =&amp;gt; color(c)); } function draw() { const mainImg = drawMain(); const overlayImg = drawOverlay(); image(mainImg, 0, 0); image(overlayImg, 0, 0); const grain = generateGrainImg(-255, 255); image(grain, 0, 0); noLoop(); } function drawMain() { const img = createGraphics(width, height); img.colorMode(HSB); img.background(&amp;#34;#117554&amp;#34;); img.noStroke(); const L = 1000; [...Array(L)].forEach((_, i) =&amp;gt; { const x = random(0, width); const y = random(0, height); const r = random(1, 2); const col = color(random(0, 360), 100, 100); img.</description></item><item><title>Sun?</title><link>https://bombrary.github.io/sketch/posts/sun-question/</link><pubDate>Tue, 17 Dec 2024 23:30:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/sun-question/</guid><description>別ページで閲覧 const PHI = 1.6180339; let yellowCol; let yellowPalette; function setup() { createCanvas(windowWidth, windowHeight); yellowPalette = [&amp;#39;#FF4545&amp;#39;, &amp;#39;#FF9C73&amp;#39;, &amp;#39;#FBD288&amp;#39;, &amp;#39;#FCF596&amp;#39;].map((c) =&amp;gt; color(c)); } function draw() { const mainImg = drawMain(); const overlayImg = drawOverlay(); image(mainImg, 0, 0); image(overlayImg, 0, 0); const grain = generateGrainImg(-255, 255); image(grain, 0, 0); noLoop(); } function drawMain() { const img = createGraphics(width, height); img.colorMode(HSB); img.background(&amp;#34;#441752&amp;#34;); img.noStroke(); const L = 1000; [...Array(L)].forEach((_, i) =&amp;gt; { const x = random(0, width); const y = random(0, height); const r = random(1, 2); const col = color(random(0, 360), 100, 100); img.</description></item><item><title>End of Night</title><link>https://bombrary.github.io/sketch/posts/end-of-night/</link><pubDate>Mon, 16 Dec 2024 23:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/end-of-night/</guid><description>別ページで閲覧 const PHI = 1.6180339; let yellowCol; function setup() { createCanvas(windowWidth, windowHeight); yellowCol = color(&amp;#39;#FFF574&amp;#39;); } function draw() { const mainImg = drawMain(); const overlayImg = drawOverlay(); image(mainImg, 0, 0); image(overlayImg, 0, 0); const grain = generateGrainImg(-255, 255); image(grain, 0, 0); noLoop(); } function drawMain() { const img = createGraphics(width, height); img.colorMode(HSB); img.background(&amp;#34;#4335A7&amp;#34;); img.noStroke(); const L = 1000; [...Array(L)].forEach((_, i) =&amp;gt; { const x = random(0, width); const y = random(0, height); const r = random(1, 2); const col = color(random(0, 360), 100, 100); img.</description></item><item><title>Look up</title><link>https://bombrary.github.io/sketch/posts/look-up/</link><pubDate>Sun, 15 Dec 2024 21:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/look-up/</guid><description>別ページで閲覧 const PHI = 1.6180339; let yellowCol; function setup() { createCanvas(windowWidth, windowHeight); yellowCol = color(&amp;#39;#FFF574&amp;#39;); } function draw() { const mainImg = drawMain(); const overlayImg = drawOverlay(); image(mainImg, 0, 0); image(overlayImg, 0, 0); const grain = generateGrainImg(-255, 255); image(grain, 0, 0); noLoop(); } function drawMain() { const img = createGraphics(width, height); img.background(0); img.noStroke(); const l = 2; const density = 250; const N = Math.floor(height / l); const M = Math.</description></item><item><title>Sight</title><link>https://bombrary.github.io/sketch/posts/sight/</link><pubDate>Sat, 14 Dec 2024 19:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/sight/</guid><description>別ページで閲覧 const PHI = 1.6180339; let W, H; let palette0, palette1; function setup() { createCanvas(windowWidth, windowHeight); palette0 = [&amp;#34;#294B29&amp;#34;, &amp;#34;#50623A&amp;#34;, &amp;#34;#789461&amp;#34;, &amp;#34;#DBE7C9&amp;#34;].map(e =&amp;gt; color(e)); palette1 = [&amp;#34;#640D5F&amp;#34;, &amp;#34;#D91656&amp;#34;, &amp;#34;#EE66A6&amp;#34;, &amp;#34;#FFEB55&amp;#34;].map(e =&amp;gt; color(e)); W = width; while (PHI * W &amp;gt; height) { W /= PHI; } H = PHI * W; } function draw() { const mainImg = drawMain(); const overlayImg = drawOverlay(); image(mainImg, 0, 0); image(overlayImg, 0, 0); noLoop(); } function drawMain() { const img = createGraphics(width, height); img.</description></item><item><title>Tripped inside out</title><link>https://bombrary.github.io/sketch/posts/tripped-inside-out/</link><pubDate>Fri, 13 Dec 2024 21:10:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/tripped-inside-out/</guid><description>別ページで閲覧 const PHI = 1.6180339; let W, H; let palette0, palette1; function setup() { createCanvas(windowWidth, windowHeight); palette0 = [&amp;#34;#243642&amp;#34;, &amp;#34;#387478&amp;#34;, &amp;#34;#629584&amp;#34;, &amp;#34;#E2F1E7&amp;#34;].map(e =&amp;gt; color(e)); palette1 = [&amp;#34;#640D5F&amp;#34;, &amp;#34;#D91656&amp;#34;, &amp;#34;#EE66A6&amp;#34;, &amp;#34;#FFEB55&amp;#34;].map(e =&amp;gt; color(e)); W = width; while (PHI * W &amp;gt; height) { W /= PHI; } H = PHI * W; } function draw() { const mainImg = drawMain(); const overlayImg = drawOverlay(); image(mainImg, 0, 0); image(overlayImg, 0, 0); noLoop(); } function drawMain() { const img = createGraphics(width, height); img.</description></item><item><title>Invitation</title><link>https://bombrary.github.io/sketch/posts/invitation/</link><pubDate>Thu, 12 Dec 2024 22:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/invitation/</guid><description>別ページで閲覧 const PHI = 1.6180339; let W, H; function setup() { createCanvas(windowWidth, windowHeight); W = width; while (PHI * W &amp;gt; height) { W /= PHI; } H = PHI * W; } function draw() { const mainImg = drawMain(); const overlayImg = drawOverlay(); image(mainImg, 0, 0); image(overlayImg, 0, 0); noLoop(); } function drawMain() { const img = createGraphics(width, height); img.background(255); img.rectMode(CENTER); const r = 50; const R = 200; const th = random(0, TWO_PI); img.</description></item><item><title>Windows</title><link>https://bombrary.github.io/sketch/posts/windows/</link><pubDate>Wed, 11 Dec 2024 21:50:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/windows/</guid><description>別ページで閲覧 const PHI = 1.6180339; let W, H; function setup() { createCanvas(windowWidth, windowHeight); W = width; while (PHI * W &amp;gt; height) { W /= PHI; } H = PHI * W; } function draw() { const mainImg = drawMain(); const overlayImg = drawOverlay(); image(mainImg, 0, 0); image(overlayImg, 0, 0); noLoop(); } function drawMain() { const img = createGraphics(width, height); img.background(0); img.rectMode(CENTER); [...Array(500)].forEach((_, i) =&amp;gt; { const x = random(0, width); const y = random(0, height); const r = random(0, 100); const col = color(&amp;#39;#7E1891&amp;#39;); col.</description></item><item><title>Rainy</title><link>https://bombrary.github.io/sketch/posts/rainy/</link><pubDate>Tue, 10 Dec 2024 23:20:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/rainy/</guid><description>別ページで閲覧 過去作品 Good Night で作ったブラシをもとに作成。
const PHI = 1.6180339; let W, H; let bluePalette; let blueBrushes; let iterMax = 100; let brushMax = 100; let layerFg, layerBg; const createBrushes = (palette, layer) =&amp;gt; { const brushes = Array.from({ length: brushMax }).map(() =&amp;gt; new Brush(layer)); brushes.forEach((brush) =&amp;gt; initBrushRandom(brush, palette)); return brushes; } const initBrushRandom = (brush, palette) =&amp;gt; { brush.init(random(0, width), random(0, height), random(-2, 0), random(0, 2), random(0, 10), random(palette)); }; class Brush { constructor(layer) { this.</description></item><item><title>Hell</title><link>https://bombrary.github.io/sketch/posts/hell/</link><pubDate>Mon, 09 Dec 2024 21:50:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/hell/</guid><description>別ページで閲覧 const PHI = 1.6180339; function setup() { createCanvas(windowWidth, windowHeight); } function draw() { const mainImg = drawMain(); const overlayImg = drawOverlay(); image(mainImg, 0, 0); image(overlayImg, 0, 0); noLoop(); } function drawMain() { const img = createGraphics(width, height); img.background(0); const M = 50; const SEP = height / M; const C0 = color(&amp;#39;#000000&amp;#39;); const C1 = color(&amp;#39;#ff0000&amp;#39;); [...Array(M)].forEach((_, i) =&amp;gt; { const x = 0; const y = SEP * i; const col = lerpColor(C0, C1, i / M); const h = height - y; img.</description></item><item><title>Window</title><link>https://bombrary.github.io/sketch/posts/window/</link><pubDate>Sun, 08 Dec 2024 21:15:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/window/</guid><description>別ページで閲覧 const PHI = 1.6180339; function setup() { createCanvas(windowWidth, windowHeight); } function draw() { const mainImg = drawMain(); const overlayImg = drawOverlay(); image(mainImg, 0, 0); image(overlayImg, 0, 0); noLoop(); } function drawMain() { const img = createGraphics(width, height); img.background(0); [...Array(500)].forEach((_, i) =&amp;gt; { const x = random(0, width); const y = random(0, height); const r = random(0, 100); const col = color(&amp;#39;#FCC737&amp;#39;); col.setAlpha(128); img.push(); img.translate(x, y); img.fill(col); img.noStroke(); img.circle(x, y, r); img.</description></item><item><title>Twilight</title><link>https://bombrary.github.io/sketch/posts/twilight/</link><pubDate>Sat, 07 Dec 2024 15:30:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/twilight/</guid><description>別ページで閲覧 const paletteCode0 = [ &amp;#39;#EB5B00&amp;#39;, &amp;#39;#F5F0CD&amp;#39;, &amp;#39;#FBD288&amp;#39;, ]; const palette0 = [] const paletteCode1 = [ &amp;#39;#f8b12f&amp;#39;, &amp;#39;#fae690&amp;#39;, &amp;#39;#f7fae8&amp;#39; ] const palette1 = [] const bgColor = &amp;#34;#211a3a&amp;#34;; const circlesNum = 200; const circlesDiamMin = 30; const circlesDiamMax = 300; function setup() { createCanvas(windowWidth, windowHeight); paletteCode0.forEach((code) =&amp;gt; { const col = color(code); palette0.push(col); }) paletteCode1.forEach((code) =&amp;gt; { const col = color(code); palette1.push(col); }) } function makeColors(palette, N) { let prev = random(palette); const result = []; [.</description></item><item><title>High Collar</title><link>https://bombrary.github.io/sketch/posts/high-collar/</link><pubDate>Fri, 06 Dec 2024 23:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/high-collar/</guid><description>別ページで閲覧 const paletteCode0 = [ &amp;#39;#EB5B00&amp;#39;, &amp;#39;#F5F0CD&amp;#39;, &amp;#39;#FBD288&amp;#39;, ]; const palette0 = [] const paletteCode1 = [ &amp;#39;#0A7373&amp;#39;, &amp;#39;#FF81D0&amp;#39;, &amp;#39;#F2C335&amp;#39;, ]; const palette1 = [] const circlesNum = 200; const circlesDiamMin = 30; const circlesDiamMax = 300; function setup() { createCanvas(windowWidth, windowHeight); paletteCode0.forEach((code) =&amp;gt; { const col = color(code); palette0.push(col); }) paletteCode1.forEach((code) =&amp;gt; { const col = color(code); palette1.push(col); }) } function makeColors(palette, N) { let prev = random(palette); const result = []; [.</description></item><item><title>Many many suns</title><link>https://bombrary.github.io/sketch/posts/many-many-suns/</link><pubDate>Thu, 05 Dec 2024 20:10:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/many-many-suns/</guid><description>別ページで閲覧 const paletteCode = [ &amp;#39;#EB5B00&amp;#39;, &amp;#39;#F5F0CD&amp;#39;, &amp;#39;#FBD288&amp;#39;, &amp;#39;#133E87&amp;#39;, ]; const palette = [] const circlesNum = 200; const circlesDiamMin = 10; const circlesDiamMax = 100; function setup() { createCanvas(windowWidth, windowHeight); paletteCode.forEach((code) =&amp;gt; { const col = color(code); palette.push(col); }) } function draw() { background(palette[palette.length - 1]); [...Array(circlesNum)].forEach((_, i) =&amp;gt; { const x = random(0, width); const y = random(0, height); const diam = map(y, 0, height, circlesDiamMin, circlesDiamMax); const idx = Math.</description></item><item><title>Bubbles or Sparks</title><link>https://bombrary.github.io/sketch/posts/bubbles-or-sparks/</link><pubDate>Wed, 04 Dec 2024 20:55:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/bubbles-or-sparks/</guid><description>別ページで閲覧 const paletteCode = [ &amp;#39;#02735E&amp;#39;, &amp;#39;#03A678&amp;#39;, &amp;#39;#F27405&amp;#39;, &amp;#39;#731702&amp;#39;, &amp;#39;#014040&amp;#39;, ]; const palette = [] const circlesNum = 200; const circlesDiamMin = 10; const circlesDiamMax = 100; function setup() { createCanvas(windowWidth, windowHeight); paletteCode.forEach((code) =&amp;gt; { const col = color(code); palette.push(col); }) } function draw() { rectMode(CENTER); background(palette[palette.length - 1]); [...Array(circlesNum)].forEach((_, i) =&amp;gt; { const x = random(0, width); const y = random(0, height); const diam = map(y, 0, height, circlesDiamMin, circlesDiamMax); const idx = Math.</description></item><item><title>Bubbles or Flowers</title><link>https://bombrary.github.io/sketch/posts/bubbles-or-flowers/</link><pubDate>Tue, 03 Dec 2024 22:20:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/bubbles-or-flowers/</guid><description>別ページで閲覧 const paletteCode = [ &amp;#39;#640D5F&amp;#39;, &amp;#39;#D91656&amp;#39;, &amp;#39;#EE66A6&amp;#39;, &amp;#39;#FFEB55&amp;#39;, ]; const palette = [] const circlesNum = 200; const circlesDiamMin = 10; const circlesDiamMax = 100; function setup() { createCanvas(windowWidth, windowHeight); paletteCode.forEach((code) =&amp;gt; { const col = color(code); palette.push(col); }) } function draw() { background(palette[palette.length - 1]); [...Array(circlesNum)].forEach((_, i) =&amp;gt; { const x = random(0, width); const y = random(0, height); const diam = map(y, 0, height, circlesDiamMin, circlesDiamMax); const idx = Math.</description></item><item><title>Spiked Bubble</title><link>https://bombrary.github.io/sketch/posts/spiked-bubble/</link><pubDate>Mon, 02 Dec 2024 21:16:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/spiked-bubble/</guid><description>別ページで閲覧 const paletteCode = [ &amp;#39;#FFF4B7&amp;#39;, &amp;#39;#006A67&amp;#39;, &amp;#39;#003161&amp;#39;, &amp;#39;#000B58&amp;#39;, ]; const palette = [] const circlesNum = 200; const circlesDiamMin = 10; const circlesDiamMax = 100; function setup() { createCanvas(windowWidth, windowHeight); paletteCode.forEach((code) =&amp;gt; { const col = color(code); palette.push(col); }) } function draw() { background(palette[palette.length - 1]); [...Array(circlesNum)].forEach((_, i) =&amp;gt; { const x = random(0, width); const y = random(0, height); const diam = map(y, 0, height, circlesDiamMin, circlesDiamMax); const idx = Math.</description></item><item><title>Bubble</title><link>https://bombrary.github.io/sketch/posts/bubble/</link><pubDate>Sun, 01 Dec 2024 21:20:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/bubble/</guid><description>別ページで閲覧 const paletteCode = [ &amp;#39;#F9C0AB&amp;#39;, &amp;#39;#F4E0AF&amp;#39;, &amp;#39;#A8CD89&amp;#39;, &amp;#39;#355F2E&amp;#39;, ]; const palette = [] const circlesNum = 200; const circlesDiamMin = 10; const circlesDiamMax = 100; function setup() { createCanvas(windowWidth, windowHeight); paletteCode.forEach((code) =&amp;gt; { const col = color(code); palette.push(col); }) } function draw() { background(palette[palette.length - 1]); [...Array(circlesNum)].forEach((_, i) =&amp;gt; { const x = random(0, width); const y = random(0, height); const diam = map(y, 0, height, circlesDiamMin, circlesDiamMax); const idx = Math.</description></item><item><title>To tomorrow</title><link>https://bombrary.github.io/sketch/posts/to-tomorrow/</link><pubDate>Sun, 31 Dec 2023 07:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/to-tomorrow/</guid><description>別ページで閲覧 const yellowPalette = [&amp;#39;#FFDD67&amp;#39;, &amp;#39;#FFCD38&amp;#39;, &amp;#39;#FEFEA4&amp;#39;]; const bluePalette = [&amp;#39;#005b98&amp;#39;, &amp;#39;#537188&amp;#39;, &amp;#39;#C2DEDC&amp;#39;]; let R; let Rs; let fragmentsCircles; let idxStep0; let imgs; let step; let grain; class Fragment { constructor(R, N, phi, th1, th2) { this.R = R; this.N = N; this.phi = phi; this.th1 = th1; this.th2 = th2; } draw(img) { img.push(); { img.noStroke(); img.beginClip(); drawPolygon(img, this.R, this.N, this.phi); img.endClip(); img.arc(0, 0, 2*this.R, 2*this.R, this.th1, this.th2); } img.</description></item><item><title>By the windows</title><link>https://bombrary.github.io/sketch/posts/by-the-windows/</link><pubDate>Sat, 30 Dec 2023 07:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/by-the-windows/</guid><description>別ページで閲覧 let yellowPalette, bluePalette; function setup() { createCanvas(windowWidth, windowHeight); yellowPalette = [&amp;#39;#f8b12f&amp;#39;, &amp;#39;#fae690&amp;#39;, &amp;#39;#f7fae8&amp;#39;].map((c) =&amp;gt; color(c)); bluePalette = [&amp;#39;#211a3a&amp;#39;, &amp;#39;#22458e&amp;#39;, &amp;#39;#63beed&amp;#39;].map((c) =&amp;gt; color(c)); } class Circle { constructor(x, y, r, n, sw) { this.x = x; this.y = y; this.r = r; this.n = n this.sw = sw; } erase(img) { img.imageMode(CENTER); img.push(); { img.translate(this.x, this.y); img.erase(); img.ellipse(0, 0, 2*this.r); img.noErase(); const imgFence = createGraphics(2*this.r, 2*this.r); for (let i = 0; i &amp;lt; this.</description></item><item><title>Solitude</title><link>https://bombrary.github.io/sketch/posts/solitude/</link><pubDate>Fri, 29 Dec 2023 07:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/solitude/</guid><description>別ページで閲覧 const vs = ` attribute vec3 aPosition; attribute vec2 aTexCoord; varying vec2 vTexCoord; void main() { vec4 positionVec4 = vec4(aPosition, 1.0); positionVec4.xy = positionVec4.xy * 2.0 - 1.0; gl_Position = positionVec4; vTexCoord = aTexCoord; } `; const fs = ` #ifdef GL_ES precision mediump float; #endif varying vec2 vTexCoord; uniform sampler2D uTex; uniform float uPhi; uniform vec2 uCenter; uniform float uPi; void main() { vec2 uv = vTexCoord; uv.</description></item><item><title>Dirty City</title><link>https://bombrary.github.io/sketch/posts/dirty-city/</link><pubDate>Thu, 28 Dec 2023 06:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/dirty-city/</guid><description>別ページで閲覧 function setup() { createCanvas(windowWidth, windowHeight); } const blurStrength = [3, 2, 1]; const bgStrength = [128, 64, 32]; function draw() { background(&amp;#39;#3D0C11&amp;#39;); fill(&amp;#39;#B4B4B3&amp;#39;); for (let i = 0; i &amp;lt; 3; i++) { if (i === 1) { push(); translate(width, height); drawGear(width/2, width/16, 20, 20); background(0, 200); pop(); } drawCity(100); push(); translate(0, height); scale(1, -1); drawCity(100); pop() if (i === 1) { drawGear(width/2, width/16, 20, 20); } filter(BLUR, blurStrength[i]); background(0, bgStrength[i]); } noLoop(); } const drawCity = (N) =&amp;gt; { for (let i = 0; i &amp;lt; N; i++) { const x = random(0, width); const w = random(width/64, width/16); const h = random(0, myMap(x)); rect(x, 0, w, h); } }; const myMap = (x) =&amp;gt; { const X = width / 2; const Y = height / 4 * 3; const y0 = Y / 4; const a = Y / X / X; return a * (x - X) * (x - X) + y0; }; const drawGear = (R, dR, N, M) =&amp;gt; { const vs = []; const dth = 0.</description></item><item><title>Moon's dance</title><link>https://bombrary.github.io/sketch/posts/moons-dance/</link><pubDate>Wed, 27 Dec 2023 06:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/moons-dance/</guid><description>別ページで閲覧 Metaballの勉強。
let grid = [] let gs = []; const D = 10; let N, M; let xDom, yDom; class Gauss { constructor(mu, sig, ro) { this.mu = mu; this.sig = sig; this.ro = ro; this.ddmu = createVector(0, 0); this.dmu = createVector(0, 0); this.c0 = TWO_PI * this.sig.x * this.sig.y * sqrt(1 - this.ro*this.ro); this.c1 = -1/2*(1 - this.ro*this.ro); } func(p) { const X = (p.x - this.mu.x) / this.</description></item><item><title>Toy's dream</title><link>https://bombrary.github.io/sketch/posts/toys-dream/</link><pubDate>Tue, 26 Dec 2023 06:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/toys-dream/</guid><description>別ページで閲覧 const palette = [&amp;#39;#461959&amp;#39;, &amp;#39;#7A316F&amp;#39;, &amp;#39;#CD6688&amp;#39;, &amp;#39;#AED8CC&amp;#39;] function setup() { createCanvas(windowWidth, windowHeight); background(255); const N = 200 * width * height / 900 / 900; const R = 50; img = createBaseImage(N, R, PI/4); image(img, 0, 0) background(255, 64); } function draw() { noLoop(); } const createBaseImage = (N, R, ang) =&amp;gt; { const img = createGraphics(width, height); for (let i = 0; i &amp;lt; N; i++) { const x = random(0, width); const y = random(0, height); img.</description></item><item><title>Happy Box</title><link>https://bombrary.github.io/sketch/posts/happy-box/</link><pubDate>Mon, 25 Dec 2023 06:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/happy-box/</guid><description>別ページで閲覧 let red = &amp;#39;#DC3535&amp;#39;; let yellow = &amp;#39;#FFE15D&amp;#39;; let green = &amp;#39;#82CD47&amp;#39;; let black = &amp;#39;#000&amp;#39;; const palette = [red, green, yellow, &amp;#39;#fff&amp;#39;]; const wreathColor = &amp;#39;#82CD47&amp;#39;; function setup() { createCanvas(windowWidth, windowHeight, WEBGL); } function draw() { red = color(red); green = color(green); yellow = color(yellow); black = color(black); const N = 10; background(255); noStroke(); rotateX(-PI/64); translate(0, 0, 400); push(); { // rotateY(-PI/16); translate(-N*100, 0, 0); for (let i = -N; i &amp;lt; N; i++) { translate(100, 0); drawBox(); } } pop(); push(); stroke(lerpColor(green, black, 0.</description></item><item><title>Wreath</title><link>https://bombrary.github.io/sketch/posts/wreath/</link><pubDate>Sun, 24 Dec 2023 09:30:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/wreath/</guid><description>別ページで閲覧 const palette = [&amp;#39;#DC3535&amp;#39;, &amp;#39;#FFE15D&amp;#39;, &amp;#39;#82CD47&amp;#39;, &amp;#39;#fff&amp;#39;]; const wreathColor = &amp;#39;#82CD47&amp;#39;; function setup() { createCanvas(windowWidth, windowHeight); background(0); } function draw() { const R = width / 4; const r = R / 2; drawDonut(R, r) const N = 1000; push(); translate(width/2, height/2); for (let i = 0; i &amp;lt; N; i++) { noStroke(); fill(random(palette)); const rpos = random(r, R); const th = random(-PI, PI); const x = rpos * cos(th); const y = rpos * sin(th); const rMax = min(R - rpos, rpos - r); ellipse(x, y, random(0, rMax)); } pop(); push(); translate(width/2, height/2); for (let i = 0; i &amp;lt; N; i++) { noStroke(); fill(random(palette)); const rpos = random(r/2, R*2); const th = random(-PI, PI); const x = rpos * cos(th); const y = rpos * sin(th); const rMax = min(R - rpos, rpos - r); ellipse(x, y, random(0, rMax)); } pop(); push(); { const img = createGraphics(width, height); img.</description></item><item><title>Fragments</title><link>https://bombrary.github.io/sketch/posts/fragments/</link><pubDate>Sat, 23 Dec 2023 05:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/fragments/</guid><description>別ページで閲覧 const palette = [&amp;#39;#FED9ED&amp;#39;, &amp;#39;#E7BCDE&amp;#39;, &amp;#39;#BB9CC0&amp;#39;] const baseCol = &amp;#39;#67729D&amp;#39; function setup() { createCanvas(windowWidth, windowHeight); background(baseCol); } function draw() { noStroke(); const N = 20; const M = 20; const D = dist(0, 0, width/2, height/2); for (let i = 0; i &amp;lt; N; i++) { for (let j = 0; j &amp;lt; M; j++) { const y = i / N * height; const x = j / M * width; const v = createVector(x - width/2, y - height/2); v.</description></item><item><title>Deep sea</title><link>https://bombrary.github.io/sketch/posts/deep-sea/</link><pubDate>Fri, 22 Dec 2023 06:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/deep-sea/</guid><description>別ページで閲覧 globalCompositeOperationを使って斜線領域を円形にくり抜く。blendModeはこの機能をラップして実装されているが（参考ソース）、すべての機能を使いたい場合はglobalCompositeOperationを直接呼び出す必要がある。入りうる値についてはCompositing and Blending Level 2が詳しい。
function setup() { createCanvas(windowWidth, windowHeight); background(255); ang = PI/4; } function draw() { background(0); const N = 100; for (let i = 0; i &amp;lt; N; i++) { const x = random(0, width); const y = random(0, height); const W = random(10, map(y, 0, height, width/4, 10)); const ang = random(-PI, PI); const col = map(y, 0, height, 255, 0); push(); translate(x, y); rotate(ang); drawEllipseLines(N, W, W, PI/4, col); pop(); } noLoop(); } const drawEllipseLines = (N, W, H, ang, col) =&amp;gt; { const img = createGraphics(W, H); img.</description></item><item><title>Blue windows</title><link>https://bombrary.github.io/sketch/posts/blue-windows/</link><pubDate>Thu, 21 Dec 2023 06:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/blue-windows/</guid><description>別ページで閲覧 前回頑張って計算して描画した斜線だが、createGraphicsで小さな領域を作ってそこで多めに線を描画してしまえば、わざわざ交点の計算をやらなくても良いことに気づいた。
function setup() { createCanvas(windowWidth, windowHeight); background(255); ang = PI/4; } function draw() { background(255); const N = 100; const diag = dist(0, 0, width/2, height/2); rectMode(CENTER); for (let i = 0; i &amp;lt; N; i++) { push(); { const x = random(0, width); const y = random(0, height); const d = random(0, 20); const w = width/4; const h = height/4; translate(x, y); const col = map(dist(x, y, width/2, height/2), 0, diag, 0, 255) stroke(col); rect(0, 0, w, h); translate(d, d); drawLines(100, w, h, PI/3, col); } pop(); } background(0, 0, 255, 32); noLoop(); } const drawLines = (N, W, H, ang, col) =&amp;gt; { const img = createGraphics(W, H); imageMode(CENTER); img.</description></item><item><title>Contained lines</title><link>https://bombrary.github.io/sketch/posts/contained-lines/</link><pubDate>Wed, 20 Dec 2023 06:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/contained-lines/</guid><description>別ページで閲覧 長方形内部を斜線で塗りつぶしたくて作り始めたが、長方形の辺と交点の計算や、交点がどこに現れるかの場合分けなどで想像以上に複雑なコードとなってしまった。
const dang = 0.01; let shapes = [] class Shape { constructor(n, x, y, w, h, ang, dir) { this.x = x; this.y = y; this.w = w; this.h = h; this.ang = ang; this.dir = dir; this.n = n } update() { this.ang += this.dir * dang; if (this.ang &amp;gt;= TWO_PI) this.ang -= TWO_PI; } draw() { push(); stroke(0); noFill(); translate(this.x, this.y); drawLines(this.n, this.w, this.h, this.ang); pop(); } } function setup() { createCanvas(windowWidth, windowHeight); background(255); ang = PI/4; const M = 300 const N = 20; for (let i = 0; i &amp;lt; M; i++) { const x = random(-width/2, width + width/2); const y = random(-height/2, height + height/2); const w = random(0, width); const h = random(0, height); const ang = random(0, TWO_PI); const dir = random([-1, 1]); shapes.</description></item><item><title>Asymmetric trees</title><link>https://bombrary.github.io/sketch/posts/asymmetric-trees/</link><pubDate>Tue, 19 Dec 2023 06:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/asymmetric-trees/</guid><description>別ページで閲覧 偶然の産物。再帰のとき、pushの後ではなく、前にrotateを入れたらやや非対称になった木々。
const D = 15; let gloI = 0; let step = 0; function setup() { createCanvas(windowWidth, windowHeight); background(255); } function draw() { translate(width/2, height/2); const N = 20; const H = height / 9; const W = width / 4; rectMode(CENTER); if (step == 0) { stroke(0); noFill(); rect(0, 0, W, H); step++; } else if (step == 1) { const x = gloI / N * W; const xn = (gloI + 1) / N * W; push(); translate(x - W/2, -H/2); drawTree(H, xn - x); pop(); if (gloI &amp;gt; N) { step++; gloI = 0; } else { gloI++; } } else if (step == 2) { const x = gloI / N * W; const xn = (gloI + 1) / N * W; push(); scale(-1, -1); translate(x - W/2, -H/2); drawTree(H, xn - x); pop(); if (gloI &amp;gt; N) { step++; } else { gloI++; } } else { noLoop(); } } const drawTree = (h, diam) =&amp;gt; { push(); rec(D, h/2, h/2); pop() fill(255); noStroke(); ellipse(0, 0, diam) } const drawRect = (h, w) =&amp;gt; { rect(0, 0, w, h); const N = 20; push(); translate(-w/2, -h/2); for (let i = 0; i &amp;lt;= N; i++) { const x = i / N * w; fill(255); push(); translate(x, 0); rec(D, h/2, h/2); pop(); const xn = (i + 1) / N * w; noStroke(); ellipse(x, 0, x - xn) } pop(); push(); translate(-w/2, h/2); scale(1, -1); for (let i = 0; i &amp;lt;= N; i++) { const x = i / N * w; fill(255); push(); translate(x, 0); rec(D, h/2, h/2); pop(); const xn = (i + 1) / N * w; noStroke(); ellipse(x, 0, x - xn) } pop(); }; const rec = (depth, len, L) =&amp;gt; { if (depth == 0) return; if (len &amp;lt;= 10) return; strokeWeight(map(len, 10, L, 0.</description></item><item><title>Random mosaic</title><link>https://bombrary.github.io/sketch/posts/random-mosaic/</link><pubDate>Mon, 18 Dec 2023 00:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/random-mosaic/</guid><description>別ページで閲覧 const palette = [&amp;#39;#B5C99A&amp;#39;, &amp;#39;#862B0D&amp;#39;, &amp;#39;#FFF9C9&amp;#39;, &amp;#39;#FFC95F&amp;#39;] let img; let step; function setup() { createCanvas(windowWidth, windowHeight); background(0); const N = 200 * width * height / 900 / 900; const R = 50; step = 200 * width * height / 900 / 900; img = createBaseImage(N, R); } function draw() { const N = 10; const xs = Array.from({ length: N }, _ =&amp;gt; random(0, width)); xs.sort((a, b) =&amp;gt; a - b); xs.</description></item><item><title>Flowers</title><link>https://bombrary.github.io/sketch/posts/flowers/</link><pubDate>Sun, 17 Dec 2023 00:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/flowers/</guid><description>別ページで閲覧 const palette = [&amp;#39;#FF90BC&amp;#39;, &amp;#39;#FFC0D9&amp;#39;, &amp;#39;#F9F9E0&amp;#39;, &amp;#39;#8ACDD7&amp;#39;] let img; let step; function setup() { createCanvas(windowWidth, windowHeight); background(0); const N = 200 * width * height / 900 / 900; const R = 50; step = 200 * width * height / 900 / 900; img = createBaseImage(N, R); } function draw() { const N = 100; const R = 10; for (let i = 0; i &amp;lt; N; i++) { const x = random(0, width); const y = random(0, height); const col = img.</description></item><item><title>Bundles</title><link>https://bombrary.github.io/sketch/posts/bundles/</link><pubDate>Sat, 16 Dec 2023 08:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/bundles/</guid><description>別ページで閲覧 const palette = [&amp;#39;#453C67&amp;#39;, &amp;#39;#6D67E4&amp;#39;, &amp;#39;#46C2CB&amp;#39;, &amp;#39;#F2F7A1&amp;#39;] function setup() { createCanvas(windowWidth, windowHeight); } function draw() { background(0); translate(width / 2, height / 2); const N = 50; const L = min(width, height) / 4; const dMax = 5 translate(-L/2, -L/2); drawColorRect(L, palette, N, 0); push(); scale(1, 1); translate(L, L); rec(dMax, L / 2, N); pop(); push(); scale(-1, -1); translate(0, 0); rec(dMax, L / 2, N); pop(); push(); scale(-1, 1); translate(0, L); rec(dMax, L / 2, N); pop(); push(); scale(1, -1); translate(L, 0); rec(dMax, L / 2, N); pop(); noLoop(); } const rec = (depth, L, N) =&amp;gt; { if (depth == 0) return; drawColorRect(L, palette, N); for (const num of chooseTwo([0, 1, 2, 3])) { if (num == 0) { push(); scale(1, 1); translate(L, L); rec(depth - 1, L / 2, N); pop(); } else if (num == 1) { push(); scale(-1, -1); translate(0, 0); rec(depth - 1, L / 2, N); pop(); } else if (num == 2) { push(); scale(-1, 1); translate(0, L); rec(depth - 1, L / 2, N); pop(); } else { push(); scale(1, -1); translate(L, 0); rec(depth - 1, L / 2, N); pop(); } } } const chooseTwo = (nums) =&amp;gt; { const shuffled = shuffle(nums); return [shuffled[0], shuffled[1]]; }; const drawColorRect = (L, palette, N) =&amp;gt; { push(); drawColorLine(0, 0, L, 0, palette, N); drawColorLine(L, 0, L, L, palette, N); drawColorLine(L, L, 0, L, palette, N); drawColorLine(0, L, 0, 0, palette, N); pop(); }; const drawColorLine = (x1, y1, x2, y2, palette, N) =&amp;gt; { const p1 = createVector(x1, y1); const p2 = createVector(x2, y2); const l = p5.</description></item><item><title>Distorted fractal</title><link>https://bombrary.github.io/sketch/posts/distorted-fractal/</link><pubDate>Fri, 15 Dec 2023 06:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/distorted-fractal/</guid><description>別ページで閲覧 const vs = ` attribute vec3 aPosition; attribute vec2 aTexCoord; varying vec2 vTexCoord; void main() { vec4 positionVec4 = vec4(aPosition, 1.0); positionVec4.xy = positionVec4.xy * 2.0 - 1.0; gl_Position = positionVec4; vTexCoord = aTexCoord; } `; const fs = ` #ifdef GL_ES precision mediump float; #endif varying vec2 vTexCoord; uniform sampler2D uTex; uniform float uPhi; uniform vec2 uCenter; void main() { vec2 uv = vTexCoord; uv.y = 1.0 - uv.</description></item><item><title>Packing 2</title><link>https://bombrary.github.io/sketch/posts/packing-2/</link><pubDate>Thu, 14 Dec 2023 00:06:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/packing-2/</guid><description>別ページで閲覧 const points = []; const palette = [&amp;#39;#04364A&amp;#39;, &amp;#39;#176B87&amp;#39;, &amp;#39;#64CCC5&amp;#39;, &amp;#39;#DAFFFB&amp;#39;] let step = 0; function setup() { createCanvas(windowWidth, windowHeight); background(random(palette)); } function draw() { const N = 10; push(); const W = random(width / 8, width / 2); const H = random(height / 8, height / 2); const x = random(0, width); const y = random(0, height); const ang = random(-PI, PI); translate(x, y); rotate(ang); drawRectArea(N, W, H); pop(); if (step &amp;gt;= 100) { noLoop(); } else { step++; } } class Shape { constructor(x, y, containerWidth, containerHeight, members) { this.</description></item><item><title>Packing</title><link>https://bombrary.github.io/sketch/posts/packing/</link><pubDate>Wed, 13 Dec 2023 06:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/packing/</guid><description>別ページで閲覧 const points = []; const palette = [&amp;#39;#711DB0&amp;#39;, &amp;#39;#C21292&amp;#39;, &amp;#39;#EF4040&amp;#39;, &amp;#39;#FFA732&amp;#39;]; function setup() { createCanvas(windowWidth, windowHeight); } function draw() { background(random(palette)); translate(width / 2, height / 2); const R = min(width/2, height/2); const N = Math.floor(R / 5); const M = Math.floor(R / 10); drawCircleArea(N, R, (x, y ,r) =&amp;gt; { push(); translate(x, y); drawCircleArea(M, r, (x, y, r) =&amp;gt; { fill(random(palette)) ellipse(x, y, 2*r); }); pop(); }); noLoop(); } class Shape { constructor(x, y, rMax) { this.</description></item><item><title>Rain city</title><link>https://bombrary.github.io/sketch/posts/rain-city/</link><pubDate>Tue, 12 Dec 2023 06:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/rain-city/</guid><description>別ページで閲覧 const points = []; function setup() { createCanvas(windowWidth, windowHeight); } function draw() { background(0); fill(255) noStroke(); drawRain(100); let prevW = 0; for (let x = 0; x &amp;lt;= width; x += prevW / 2) { const w = random(width/32, width / 4); const h = random(height/128, height / 4); fill(random(64, 128)); push(); translate(x, height - h); rect(0, 0, w, h); pop(); prevW = w; } drawRain(100); noLoop(); } const drawRain = (N) =&amp;gt; { fill(&amp;#39;#192655&amp;#39;); for (let i = 0; i &amp;lt; N; i++) { const p = createVector(random(0, width), random(0, height)) let r = random(0, 10); while (r &amp;gt;= 1e-5) { ellipse(p.</description></item><item><title>Leaves</title><link>https://bombrary.github.io/sketch/posts/leaves/</link><pubDate>Mon, 11 Dec 2023 06:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/leaves/</guid><description>別ページで閲覧 Perlin noiseを使ってflow fieldを作成するアイデアは、以下のYouTube動画から得た。
How to make a flow field in p5.js | Coding Project #9
const points = []; function setup() { createCanvas(windowWidth, windowHeight); const spacing = 10; const N = min(Math.floor(width / spacing), 100); const M = min(Math.floor(height / spacing), 100); for (let i = 0; i &amp;lt;= N; i++) { for (let j = 0; j &amp;lt;= M; j++) { const y = height / N * i; const x = width / M * j; points.</description></item><item><title>Molecules</title><link>https://bombrary.github.io/sketch/posts/molecules/</link><pubDate>Sun, 10 Dec 2023 09:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/molecules/</guid><description>別ページで閲覧 function setup() { createCanvas(windowWidth, windowHeight); } function draw() { background(255); const palette = [&amp;#39;#14471E&amp;#39;, &amp;#39;#68904D&amp;#39;, &amp;#39;#C8D2D1&amp;#39;, &amp;#39;#EE9B01&amp;#39;, &amp;#39;#DA6A00&amp;#39;]; const N = 10; const M = 10; const W = max(width / N, height / M); // L = 1.5*R // W = 6*R + 2*L = 9*R -&amp;gt; R = W/9 const R = W/9; const L = 1.5*R for (let i = 0; i &amp;lt; N; i++) { for (let j = 0; j &amp;lt; M; j++) { const x = W * j; const y = W * i; push(); translate(W/2, W/2); translate(x, y); const p = shuffle(palette); rotate(map(noise(i * 0.</description></item><item><title>Overlapped bubbles</title><link>https://bombrary.github.io/sketch/posts/overlapped-bubbles/</link><pubDate>Sat, 09 Dec 2023 05:30:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/overlapped-bubbles/</guid><description> 別ページで閲覧 let step = 0 const stepMax = 100; const circleNum = 50; let rMax; function setup() { createCanvas(windowWidth, windowHeight); rMax = min(width, height) / 10; } function draw() { const W = 100 const H = 25; noStroke(); fill(255, 255, 255, 128); drawBlink(W, H, height / W); drawRandomCircles(circleNum, rMax); if (step &amp;gt;= stepMax) { noLoop(); } step++; } const drawRandomCircles = (N) =&amp;gt; { for (let i = 0; i &amp;lt; N; i++) { const x = random(0, width); const y = random(0, height); const r = random(0, rMax); const col = random([&amp;#39;#527853&amp;#39;, &amp;#39;#F9E8D9&amp;#39;, &amp;#39;#F7B787&amp;#39;, &amp;#39;#EE7214&amp;#39;]); fill(col); noStroke(); ellipse(x, y, r); } }; const drawBlink = (W, H, N) =&amp;gt; { push(); for (let i = 0; i &amp;lt; N; i++) { drawLine(W, H, width / H) translate(0, W); } pop(); } const drawLine = (W, H, N) =&amp;gt; { push() for (let i = 0; i &amp;lt; N; i++) { if (random([true, false])) { rect(0, 0, W, H); translate(W, 0); } else { rect(0, 0, H, W); translate(H, 0); } } pop(); };</description></item><item><title>Gears</title><link>https://bombrary.github.io/sketch/posts/gears/</link><pubDate>Fri, 08 Dec 2023 07:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/gears/</guid><description>別ページで閲覧 function setup() { createCanvas(windowWidth, windowHeight); } function draw() { background(&amp;#39;#45474B&amp;#39;); drawRandomGears(20, min(width/2, height/2) * 0.5); push(); { translate(0, height); fill(255); noStroke(); const R = min(width/2, height/2) * 1.5; drawGear(R, R/10, 20, 5); } pop(); push(); { translate(width, height); fill(0); noStroke(); const R = min(width/2, height/2); drawGear(R, R/10, 20, 5); } pop(); noLoop(); } const drawRandomGears = (N, R) =&amp;gt; { for (let i = 0; i &amp;lt; N; i++) { const num = random([0, 1, 2, 3]); const [x, y] = (() =&amp;gt; { if (num == 0) { return [random(0, width), 0]; } else if (num == 1) { return [random(0, width), height]; } else if (num == 2) { return [0, random(0, height)]; } else if (num == 3) { return [width, random(0, height)]; } })(); const r = random(10, R); push(); { translate(x, y); if (random([0, 1]) == 0) { fill(0); } else { fill(255); } noStroke(); drawGear(r, r/10, 20, 5); } pop(); } } const drawGear = (R, dR, N, M) =&amp;gt; { const vs = [] const dth = 0.</description></item><item><title>Crazy bars</title><link>https://bombrary.github.io/sketch/posts/crazy-bars/</link><pubDate>Thu, 07 Dec 2023 07:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/crazy-bars/</guid><description>別ページで閲覧 シェーダーの練習。 参考サイトは以下。
【p5.js】シェーダー（GLSL）でポストエフェクト p5.js shaders const vs = ` attribute vec3 aPosition; attribute vec2 aTexCoord; varying vec2 vTexCoord; void main() { vec4 positionVec4 = vec4(aPosition, 1.0); positionVec4.xy = positionVec4.xy * 2.0 - 1.0; gl_Position = positionVec4; vTexCoord = aTexCoord; } `; const fs = ` #ifdef GL_ES precision mediump float; #endif varying vec2 vTexCoord; uniform sampler2D uTex; uniform float uPi; uniform float uTime; void main() { vec2 uv = vTexCoord; uv.</description></item><item><title>Simple wall</title><link>https://bombrary.github.io/sketch/posts/simple-wall/</link><pubDate>Wed, 06 Dec 2023 07:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/simple-wall/</guid><description>別ページで閲覧 const palette = [&amp;#39;#FDF7E4&amp;#39;, &amp;#39;#FAEED1&amp;#39;, &amp;#39;#DED0B6&amp;#39;, &amp;#39;#BBAB8C&amp;#39;]; function setup() { createCanvas(windowWidth, windowHeight); background(random(palette)); } function draw() { const dx = 10; const dy = 10; for (let x = 0; x &amp;lt; width; x += dx) { drawLine(x, 0, x, height); } for (let y = 0; y &amp;lt; height; y += dy) { drawLine(0, y, width, y); } noLoop(); } const drawLine = (x0, y0, x1, y1) =&amp;gt; { const R = 5; const v = createVector(x1 - x0, y1 - y0); v.</description></item><item><title>Hello Universe</title><link>https://bombrary.github.io/sketch/posts/hello-universe/</link><pubDate>Tue, 05 Dec 2023 07:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/hello-universe/</guid><description>別ページで閲覧 const palette = [&amp;#39;#DF826C&amp;#39;, &amp;#39;#F8FFD2&amp;#39;, &amp;#39;#D0F288&amp;#39;, &amp;#39;#8ADAB2&amp;#39;] const palette2 = [&amp;#39;#2E4374&amp;#39;, &amp;#39;#5f3c8f&amp;#39;, &amp;#39;#2a3aac&amp;#39;] const bg = &amp;#39;#31304D&amp;#39; const circleBase = &amp;#39;#00001a&amp;#39; function setup() { createCanvas(windowWidth, windowHeight); } function draw() { background(bg); const baseImg = filterImage(createBaseImage(), (img, x, y) =&amp;gt; img.get(x, y)); image(baseImg, 0, 0); const foreImg = createCircleImage() erase(); image(foreImg, 0, 0); const foreImgFiltered = filterImage(foreImg, (img, x, y) =&amp;gt; { const c = color(img.get(x, y)); if (alpha(c) &amp;gt;= 1e-5) { const repCol = new Array(10).</description></item><item><title>Drift</title><link>https://bombrary.github.io/sketch/posts/drift/</link><pubDate>Mon, 04 Dec 2023 06:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/drift/</guid><description>別ページで閲覧 const dt = 0.01; let t = 0; const bgColor = &amp;#39;#2f343d&amp;#39; const palette = [&amp;#39;#b7c0cb&amp;#39;, &amp;#39;#e4d6df&amp;#39;, &amp;#39;#c19297&amp;#39;] const ys = [] const drifts = []; const T = 5; function setup() { createCanvas(windowWidth, windowHeight); background(bgColor); for (let i = 0; i &amp;lt; 3; i++) { const seeds = [random(0, 100), random(0, 100)]; drifts.push(new Drift(T, palette, random(-PI, PI), seeds)); } for (let i = 0; i &amp;lt; 2; i++) { const seeds = [random(0, 100), random(0, 100)]; drifts.</description></item><item><title>Wave of circles</title><link>https://bombrary.github.io/sketch/posts/wave-of-circles/</link><pubDate>Sun, 03 Dec 2023 10:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/wave-of-circles/</guid><description>別ページで閲覧 let palette; let bgColor; const modifyCol = (hex) =&amp;gt; { const c = color(hex); return color(hue(c), saturation(c)/2, brightness(c) * 2); }; function setup() { colorMode(HSB, 100); palette = [&amp;#39;#335c67&amp;#39;, &amp;#39;#e09f3e&amp;#39;, &amp;#39;#9e2a2b&amp;#39;, &amp;#39;#540b0e&amp;#39;].map(modifyCol); bgColor = modifyCol(&amp;#39;#fff3b0&amp;#39;); createCanvas(windowWidth, windowHeight); background(bgColor); } const drawSin = (x0, y0, x1, y1, N, amp, R) =&amp;gt; { const D = dist(x0, y0, x1, y1); const TH = atan2(y1 - y0, x1 - x0); push(); translate(x0, y0); rotate(TH); for (let i = 0; i &amp;lt; N + 1; i++) { const th = TWO_PI/N * i; const x = D/N * i; const y = amp*sin(th); const r = random(R/2, R); ellipse(x, y, r); } pop(); }; class PaletteQueue { constructor(palette) { this.</description></item><item><title>Rotation pattern</title><link>https://bombrary.github.io/sketch/posts/rot-pattern/</link><pubDate>Sat, 02 Dec 2023 06:30:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/rot-pattern/</guid><description>別ページで閲覧 function setup() { colorMode(HSB); createCanvas(windowWidth, windowHeight); } const rec = (x, y, len, drawFunc) =&amp;gt; { if (len &amp;lt; 1.0) { return } translate(x, y); rotate(PI/2); const pad = 5; const N = 10; for (let i = 0; i &amp;lt; N; i++) { drawFunc(len, pad*i); } rec(0, len, len/1.2, drawFunc); }; const drawFuncs = [ (len, offset) =&amp;gt; { line( offset, offset, offset, len-offset) }, (len, offset) =&amp;gt; { line(-offset, -offset, offset, len-offset) }, (len, offset) =&amp;gt; { line(-offset, offset, -offset, len-offset) }, (len, offset) =&amp;gt; { line( offset, 0, -offset, len-offset) }, ] function draw() { const lenMax = 200; const N = 20; background(0) stroke(&amp;#39;#47266e&amp;#39;); for (let i = 0; i &amp;lt; N; i++) { push(); translate(random(0, width), random(0, height)); rotate(random(0, TWO_PI)); const f = random(drawFuncs); drawingContext.</description></item><item><title>Kurukuru</title><link>https://bombrary.github.io/sketch/posts/kurukuru/</link><pubDate>Fri, 01 Dec 2023 08:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/kurukuru/</guid><description> 別ページで閲覧 let palette = []; function setup() { createCanvas(windowWidth, windowHeight); background(255); palette = [&amp;#39;#F4EAD5&amp;#39;, &amp;#39;#CCD6A6&amp;#39;, &amp;#39;#FF9E9E&amp;#39;].map((c) =&amp;gt; color(c)); } const randomColor = () =&amp;gt; { return random(palette); } const drawCircle = (x, y, R, fillCol, strokeCol) =&amp;gt; { if (R &amp;lt; 1) { return } fill(fillCol) stroke(strokeCol) circle(x, y, 2*R) const ang = random(-PI/2, PI/2); const newX = random(0, R/2)*cos(ang) + x; const newY = random(0, R/2)*sin(ang) + y; const rMax = R - dist(x, y, newX, newY) const newR = random(rMax/2, rMax); drawCircle(newX, newY, newR, randomColor(), randomColor()) }; function draw() { noStroke(); const N = 10; const M = 20; const R = min(windowWidth/M, windowHeight/N)/2; for (let i = 0; i &amp;lt; N; i++) { for (let j = 0; j &amp;lt; M; j++) { const y = i * windowHeight/N + R; const x = j * windowWidth/M + R; drawCircle(x, y, R, randomColor(), randomColor()); } } noLoop(); }</description></item><item><title>Untitled 20230119</title><link>https://bombrary.github.io/sketch/posts/20230119/</link><pubDate>Thu, 19 Jan 2023 17:16:59 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/20230119/</guid><description> 別ページで閲覧 &amp;#34;use strict&amp;#34;; const colBg = &amp;#39;#FAECD6&amp;#39;; const colFg = &amp;#39;#243763&amp;#39;; let radMax, radMin; let W, H; function setup() { createCanvas(windowWidth, windowHeight); background(colBg); radMin = min(width/72); radMax = min(50, width*0.1); H = height/2; W = width/8*7; } function draw() { noLoop(); rectMode(CENTER); push(); translate(width/2, height/2); noStroke(); fill(colFg); rect(0, 0, W, H); for (let i = 0; i &amp;lt; 20; i++) { const num = random(3); if (num &amp;lt; 1) { symmetryTriangle(); } else if(num &amp;lt; 2) { symmetryCircle(); } else { symmetryRect(); } } pop(); } const symmetryTriangle = () =&amp;gt; { const rad = random(radMin, radMax) push(); symmetry(H, () =&amp;gt; { translate(random(-W/2 + rad , W/2 - rad), random(-H/4, 0)); rotate(random(0, TWO_PI)); }, () =&amp;gt; { triangle(rad*cos(0), rad*sin(0), rad*cos(PI/3*2), rad*sin(PI/3*2), rad*cos(PI/3*4), rad*sin(PI/3*4)); }); pop(); }; const symmetryRect = () =&amp;gt; { const rad = random(radMin, radMax) const len = 2 * rad; push(); symmetry(H, () =&amp;gt; { translate(random(-W/2 + rad , W/2 - rad), random(-H/4, 0)); rotate(random(0, TWO_PI)); }, () =&amp;gt; { rect(0, 0, len, len) }); pop(); }; const symmetryCircle = () =&amp;gt; { const rad = random(radMin, radMax) push(); symmetry(H, () =&amp;gt; { translate(random(-W/2 + rad , W/2 - rad), random(-H/4, 0)); }, () =&amp;gt; { circle(0, 0, 2*rad) }); pop(); }; const symmetry = (L, preDrawFunc, drawFunc) =&amp;gt; { push(); fill(colFg); noStroke(); translate(0, -L/2); preDrawFunc(); drawFunc(); pop(); push(); fill(colBg); translate(0, L/2); noStroke(); preDrawFunc(); drawFunc(); pop(); }</description></item><item><title>Gentle Space</title><link>https://bombrary.github.io/sketch/posts/gentle-space/</link><pubDate>Sat, 31 Dec 2022 18:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/gentle-space/</guid><description>別ページで閲覧 &amp;#34;use strict&amp;#34;; let step = 0; let bubbleCount = 20; const colWipe = &amp;#39;#FA6700&amp;#39;; const colLight = &amp;#39;#FFD8A9&amp;#39;; const colBulb = &amp;#39;#FFFAD7&amp;#39; function setup() { createCanvas(windowWidth, windowHeight); } function draw() { if (step === 0) { background(16); step++; } else if (step === 1) { const wMin = min(map(width, 0, 1440, 0, 20), 20); const wMax = min(map(width, 0, 1440, 0, 40), 40); for (let i = 0; i &amp;lt; 10; i++) { drawLamp(random(0, width), height/4 + random(-height/4, height/4), random(wMin, wMax)); } step++; } else if (step === 2) { filter(BLUR, 3); step++; } else if (step === 3) { const wMin = min(map(width, 0, 1440, 0, 40), 40); const wMax = min(map(width, 0, 1440, 0, 90), 90); for (let i = 0; i &amp;lt; 10; i++) { drawLamp(random(0, width), height/2 + random(-height/8, height/8), random(wMin, wMax)); } step++; } else if (step === 4) { const img = generateBubble(); image(img, random(0, width), random(0, height)); bubbleCount--; if (bubbleCount === 0) { step++; } } else if (step === 5) { const img = generateWipe(); image(img, 0, 0); step++; } else if (step === 6) { const img = generateGrainImg(-255, 255); image(img, 0, 0); step++; } else { noLoop(); } } const generateBubble = () =&amp;gt; { const R = random(10, 100); const img = createGraphics(4*R, 4*R); const a = random(16, 32); img.</description></item><item><title>Sunset</title><link>https://bombrary.github.io/sketch/posts/sunset/</link><pubDate>Fri, 30 Dec 2022 18:26:11 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/sunset/</guid><description>別ページで閲覧 &amp;#34;use strict&amp;#34;; let palette; function setup() { createCanvas(windowWidth, windowHeight); palette = [&amp;#39;#DC3535&amp;#39;, &amp;#39;#212121&amp;#39;, &amp;#39;#000&amp;#39;, &amp;#39;#FFE15D&amp;#39;].map((c) =&amp;gt; color(c)); } function draw() { noLoop(); background(255); const t = frameCount / 50; const rate = (3 -sqrt(5))/2; noStroke(); const R0 = min(map(width, 0, 720, 0, 100), 100); const RMax = max(width, height) const rs = []; for (let r = R0; r &amp;lt; RMax; r += R0) { rs.push(r); } push(); translate(width/2, height*rate); for (let i = rs.</description></item><item><title>Fabric</title><link>https://bombrary.github.io/sketch/posts/fabric/</link><pubDate>Thu, 29 Dec 2022 19:04:54 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/fabric/</guid><description>別ページで閲覧 &amp;#34;use strict&amp;#34;; let palette, colBg; function setup() { pixelDensity(1); createCanvas(windowWidth, windowHeight); colBg = color(&amp;#39;#FCFFE7&amp;#39;); palette = [&amp;#39;#D2001A&amp;#39;, &amp;#39;#2B3467&amp;#39;, &amp;#39;#EF5B0C&amp;#39;].map((c) =&amp;gt; lerpColor(color(c), colBg, 0.25) ); } function draw() { noLoop(); background(colBg); translate(width/2, height/2); noStroke(255); let shapeNum = 3; const r0 = min(map(width, 0, 720, 0, 100), 100); const L = max(width, height); const rs = []; for (let r = r0; r &amp;lt; L; r += r0) { rs.push(r); } for (let i = 0; i &amp;lt; rs.</description></item><item><title>A Memory</title><link>https://bombrary.github.io/sketch/posts/a-memory/</link><pubDate>Wed, 28 Dec 2022 17:43:49 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/a-memory/</guid><description>別ページで閲覧 &amp;#34;use strict&amp;#34;; let colBg; let palette; let lineDrawer; let maskImg; let scrambleCount; function setup() { pixelDensity(1); createCanvas(windowWidth, windowHeight); const paletteBase = [&amp;#39;#61876E&amp;#39;, &amp;#39;#A6BB8D&amp;#39;, &amp;#39;#EAE7B1&amp;#39;].map((c) =&amp;gt; { const col = color(c); col.setAlpha(128); return col; }); palette = duplicate([5,1,1], paletteBase); colBg = color(&amp;#39;#3C6255&amp;#39;); scrambleCount = 3; maskImg = createGraphics(width, height); maskImg.fill(colBg); maskImg.noStroke(); drawHill(maskImg); lineDrawer = new LineDrawer(); background(colBg); fill(255, 192); noStroke(); drawCircles(width/8, width/2, 10); image(maskImg, 0, 0); } function draw() { lineDrawer.</description></item><item><title>Pop Circles</title><link>https://bombrary.github.io/sketch/posts/pop-circles/</link><pubDate>Tue, 27 Dec 2022 18:39:49 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/pop-circles/</guid><description>別ページで閲覧 &amp;#34;use strict&amp;#34;; const depthMax = 5; let palette; let xOff, yOff; let dx, dy; let R, r; function setup() { createCanvas(windowWidth, windowHeight); palette = [&amp;#39;#d92923&amp;#39;, &amp;#39;#005994&amp;#39;, &amp;#39;#e2d46c&amp;#39;].map((c) =&amp;gt; { const col = color(c); col.setAlpha(196); return col; }); xOff = 0; yOff = 0; R = map(width, 0, 720, 0, 80); r = map(width, 0, 720, 0, 10); dx = 3*R; dy = 3*R; } function draw() { drawEllipses(xOff, yOff, R, R, r, r, 12, 0); xOff += dx; if (xOff &amp;gt; 1.</description></item><item><title>Baloons</title><link>https://bombrary.github.io/sketch/posts/baloons/</link><pubDate>Mon, 26 Dec 2022 18:58:01 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/baloons/</guid><description>別ページで閲覧 &amp;#34;use strict&amp;#34;; let palette; function setup() { pixelDensity(1); createCanvas(windowWidth, windowHeight); background(0); // red, purple, yellow, green, blue palette = [&amp;#39;#FD8A8A&amp;#39;, &amp;#39;#BA94D1&amp;#39;, &amp;#39;#FFF89A&amp;#39;, &amp;#39;#B6E2A1&amp;#39;, &amp;#39;#9ADCFF&amp;#39;]; } function draw() { background(255); noLoop(); const H = min(map(height, 0, 820, 0, 100), 100); push(); translate(width/2, height/2); drawRectangle(width/2, H, 10); pop(); overlayNoise(); } const overlayNoise = () =&amp;gt; { loadPixels(); for (let x = 0; x &amp;lt; width; x++) { for (let y = 0; y &amp;lt; height; y++) { const i = (y * width + x) * 4; const dr = random(-20, 20); const dg = random(-20, 20); const db = random(-20, 20); if (pixels[i + 0] !</description></item><item><title>Present Box</title><link>https://bombrary.github.io/sketch/posts/present-box/</link><pubDate>Sun, 25 Dec 2022 18:57:22 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/present-box/</guid><description>別ページで閲覧 &amp;#34;use strict&amp;#34;; let palette; function setup() { createCanvas(windowWidth, windowHeight); background(0); palette = [&amp;#39;#DC3535&amp;#39;, &amp;#39;#FFE15D&amp;#39;, &amp;#39;#82CD47&amp;#39;, &amp;#39;#fff&amp;#39;].map((c) =&amp;gt; { const col = color(c); col.setAlpha(65); return col; }); } function draw() { background(0); noLoop(); const l = min(min(width, height), 720); const a = l/4; const b = l/4; const c = l/4; const cubicImg = createCuboidImg(50, a, b, c); const bgImg = createGrainImg(width, height, 50, 1, 100); image(bgImg, 0, 0); image(cubicImg, 0, 0); } const createCuboidImg = (N, a, b, c) =&amp;gt; { const img = createGraphics(width, height, WEBGL); const cam = img.</description></item><item><title>Merry Christmas</title><link>https://bombrary.github.io/sketch/posts/merry-christmas-2022/</link><pubDate>Sat, 24 Dec 2022 19:13:01 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/merry-christmas-2022/</guid><description>別ページで閲覧 &amp;#34;use strict&amp;#34;; let fgImg, bgImg; let starPalette; function setup() { pixelDensity(1); createCanvas(windowWidth, windowHeight); starPalette = [&amp;#39;#DC3535&amp;#39;, &amp;#39;#FFE15D&amp;#39;, &amp;#39;#82CD47&amp;#39;, &amp;#39;#fff&amp;#39;]; fgImg = createGraphics(width, height); bgImg = createGraphics(width, height); } function draw() { background(0); noLoop(); drawBg(100, 1, 15); image(bgImg, 0, 0); filter(BLUR, 1); drawFg(); image(fgImg, 0, 0); bgImg.clear(); drawBg(1000, 1, 5); image(bgImg, 0, 0); drawGrain(); } const drawFg = () =&amp;gt; { // Cone Top y_{i}: y_{i} = y_{i-1} + b r0 // Cone Rad r_{i}: r_{i} = a r_{i-1} // Cone Bottom h_{i}: h_{i} = y_{i} + r_{i} const a = 3/2; const b = 1/3; const N = 5; let y = 0; let r = calcR0(a, b, 0, N); const r0 = r; const ys = [y]; const rs = [r]; for (let i = 0; i &amp;lt;= N+1; i++) { y = y + r0/3; r *= a; ys.</description></item><item><title>Noisy Waves</title><link>https://bombrary.github.io/sketch/posts/noisy-waves/</link><pubDate>Fri, 23 Dec 2022 18:44:36 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/noisy-waves/</guid><description>別ページで閲覧 &amp;#34;use strict&amp;#34;; let palettes; let t; const waveNum = 5; function setup() { createCanvas(windowWidth, windowHeight); const palette1 = [&amp;#39;#49FF00&amp;#39;, &amp;#39;#FBFF00&amp;#39;, &amp;#39;#FF9300&amp;#39;, &amp;#39;#FF0000&amp;#39;]; const palette2 = [&amp;#39;#4D089A&amp;#39;, &amp;#39;#323EDD&amp;#39;, &amp;#39;#DC2ADE&amp;#39;, &amp;#39;#E8F044&amp;#39;]; const palette3 = [&amp;#39;#3FC5F0&amp;#39;, &amp;#39;#42DEE1&amp;#39;, &amp;#39;#6DECB9&amp;#39;, &amp;#39;#EEF5B2&amp;#39;]; const palette4 = [&amp;#39;#2EC1AC&amp;#39;, &amp;#39;#3E978B&amp;#39;, &amp;#39;#D2E603&amp;#39;, &amp;#39;#EFF48E&amp;#39;]; const palette5 = [&amp;#39;#8C0000&amp;#39;, &amp;#39;#BD2000&amp;#39;, &amp;#39;#FA1E0E&amp;#39;, &amp;#39;#FFBE0F&amp;#39;]; palettes = shuffle([palette1, palette2, palette3, palette4, palette5]); t = 0; background(0); } function draw() { const rad = height / (waveNum - 1) / 2; const waves = []; for (let i = 0; i &amp;lt; waveNum; i++) { const y = i * 2*rad; waves.</description></item><item><title>Circle Drops</title><link>https://bombrary.github.io/sketch/posts/circle-drops/</link><pubDate>Thu, 22 Dec 2022 17:35:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/circle-drops/</guid><description>別ページで閲覧 &amp;#34;use strict&amp;#34;; let maskImg, fgImg; const colorBg = &amp;#39;#242F9B&amp;#39;; const colorFg = &amp;#39;#F1F6F5&amp;#39;; let palette; let RMax; function setup() { createCanvas(windowWidth, windowHeight); maskImg = createGraphics(width, height); fgImg = createGraphics(width, height); palette = [&amp;#39;#242F9B&amp;#39;, &amp;#39;#82C3EC&amp;#39;].map((c) =&amp;gt; color(c)); RMax = width/10; } function draw() { background(&amp;#39;white&amp;#39;); const [isFound, x] = findX(); if (isFound) { // x1 ---- x ---- x2 const x1 = searchNeighborLineX(x, -1); const x2 = searchNeighborLineX(x, 1); const rMax = min(x - x1, x2 - x); const r = random(rMax/2, min(rMax, RMax)); const dy = 2*r + random(r/2, 2*r); drawShapesLine(x, dy, () =&amp;gt; { fgImg.</description></item><item><title>Wonderland</title><link>https://bombrary.github.io/sketch/posts/wonderland/</link><pubDate>Wed, 21 Dec 2022 19:36:41 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/wonderland/</guid><description>別ページで閲覧 &amp;#34;use strict&amp;#34;; const depthMax = 30; let R; function setup() { pixelDensity(1); createCanvas(windowWidth, windowHeight); colorMode(HSB); rectMode(CENTER); R = min(width/2, height/2); } function draw() { background(255); push(); translate(0, height); drawCircle(20); pop(); push(); translate(width, 0); rotate(PI); drawCircle(20); pop(); noLoop(); } const drawCircle = (rotNum) =&amp;gt; { for (let i = 0; i &amp;lt; rotNum; i++) { const sang = i / rotNum * TWO_PI/4 - TWO_PI/4; const eang = (i + 1) / rotNum * TWO_PI/4 - TWO_PI/4; const col = color(random(0, 360), 50, 100, 1); stroke(col); const mang = (i + 0.</description></item><item><title>Starfish</title><link>https://bombrary.github.io/sketch/posts/starfish/</link><pubDate>Tue, 20 Dec 2022 15:57:35 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/starfish/</guid><description>別ページで閲覧 Context FreeとかStructure Synthのような、再帰的な構造の生成に特化したソフトウェアなら、もっと簡潔に書けるはず。
&amp;#34;use strict&amp;#34;; const depthMax = 20; let palette; let rectLen, rectSep; function setup() { pixelDensity(1); createCanvas(windowWidth, windowHeight); palette = [&amp;#39;#DC3535&amp;#39;, &amp;#39;#FFE15D&amp;#39;, &amp;#39;#001253&amp;#39;].map((c) =&amp;gt; color(c)); rectLen = min(width, height) / depthMax * 1.1; rectSep = rectLen / 11; } function draw() { background(0); rectMode(CENTER); noStroke(); translate(width/2, height/2); const angles = Array.from({ length: 20 }).map((_, i) =&amp;gt; i / 20 * TWO_PI); shuffle(angles, true); for (let i = 0; i &amp;lt; 10; i++) { const x = random(-width/2, width/2); const y = random(-height/2, height/2); const cols = shuffle(palette); drawShapesAt(x, y, 0.</description></item><item><title>Gaussian City</title><link>https://bombrary.github.io/sketch/posts/gaussian-city/</link><pubDate>Mon, 19 Dec 2022 15:40:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/gaussian-city/</guid><description>別ページで閲覧 ガウス分布から2次元座標をサンプリングし，それをビル群に見立てた．ランダムな間隔で道路を引くことでより都市感が出せた．
&amp;#34;use strict&amp;#34;; let cam, img, boxLen; const board = []; const [nRow, nCol] = [50, 50]; let rotX, rotY, rotZ; const samplingNum = 10000; const variance = 4; function setup() { createCanvas(windowWidth, windowHeight, WEBGL); boxLen = min(min(width, height)/15, 50); for (let i = 0; i &amp;lt; nRow; i++) { board.push(Array.from({ length: nCol }).map(() =&amp;gt; 0)); } for (let i = 0; i &amp;lt; samplingNum; i++) { const x = randomGaussian(nCol/2, variance); const y = randomGaussian(nRow/2, variance); if (0 &amp;lt;= x &amp;amp;&amp;amp; x &amp;lt; nCol &amp;amp;&amp;amp; 0 &amp;lt;= y &amp;amp;&amp;amp; y &amp;lt; nRow) { board[floor(y)][floor(x)] += 0.</description></item><item><title>Crystal</title><link>https://bombrary.github.io/sketch/posts/crystal/</link><pubDate>Sun, 18 Dec 2022 20:18:27 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/crystal/</guid><description>別ページで閲覧 凸多角形の描画は以下のサイトを参考にした：Generating Random Convex Polygons．今回作ったコードでは，convexPolygonRandom関数が凸多角形の頂点を生成する役目を担っている．
let palette; const iterMax = 100; function setup() { createCanvas(windowWidth, windowHeight); palette = [&amp;#39;#332FD0&amp;#39;, &amp;#39;#C147E9&amp;#39;, &amp;#39;#00E7FF&amp;#39;].map((c) =&amp;gt; { const col = color(c); col.setAlpha(128); return col; }); background(0); } function draw() { for (let i = 0; i &amp;lt; iterMax; i++) { const x = random(0, width); const y = random(0, height); const [r, g, b, _] = get(x, y); const n = floor(random(3, 8)); if (r &amp;lt; 64 &amp;amp;&amp;amp; g &amp;lt; 64 &amp;amp;&amp;amp; b &amp;lt; 64) { drawPolygon(x, y, 100, 100, n); } } } const drawPolygon = (x, y, w, h, n) =&amp;gt; { const poly = convexPolygonRandom(n, w, h); const col = (() =&amp;gt; { const t = x / width + random(-0.</description></item><item><title>Vases</title><link>https://bombrary.github.io/sketch/posts/vases/</link><pubDate>Sat, 17 Dec 2022 21:23:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/vases/</guid><description>別ページで閲覧 const factor = 2; const maxXSep = 60; const maxNCols = 12; function setup() { createCanvas(windowWidth, windowHeight); const palette = [&amp;#39;#E14D2A&amp;#39;, &amp;#39;#FD841F&amp;#39;, &amp;#39;#3E6D9C&amp;#39;, &amp;#39;#001253&amp;#39;].map((c) =&amp;gt; { const col = color(c); col.setAlpha(64); return col; }) const xSep = min(width / maxNCols, maxXSep); const nCols = width / xSep; const ySep = xSep * factor; const nRows = ceil(height / ySep); const xRad = xSep / 2 * 0.5; const yRad = xRad/2; for (let i = 0; i &amp;lt; nRows; i++) { for (let j = 0; j &amp;lt; nCols; j++) { const x = j * xSep + xSep/2; const y = i * ySep + ySep/2; fill(random(palette)); const t1 = random(0, 1); const t2 = random(0, 1); drawShapeBroken(x, y, xRad, yRad, ySep - 2*yRad, t1, t2); } } } const drawShapeBroken = (x, y, xRad, yRad, h, t1, t2) =&amp;gt; { rectMode(CENTER); push(); translate(x, y); translate(0, -h/2); for (let i = 0; i &amp;lt; 10; i++) { drawingContext.</description></item><item><title>Random Koch Curve</title><link>https://bombrary.github.io/sketch/posts/random-koch-curve/</link><pubDate>Fri, 16 Dec 2022 22:23:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/random-koch-curve/</guid><description>別ページで閲覧 滲み感を出す練習 + コッホ曲線（をランダムにしたもの）の練習。
半透明の色を塗り重ねれば滲みを表現できることは、以下のサイトから学んだ： HOW TO HACK A PAINTING。 blendModeをいじってみると，重ね塗りの感じが変わって面白い。
const depthMax = 5; let curblendMode; let palette; let sel; function setup() { createCanvas(windowWidth, windowHeight); palette = [&amp;#39;#EB455F&amp;#39;, &amp;#39;#4B56D2&amp;#39;, &amp;#39;#FED049&amp;#39;].map((c) =&amp;gt; { const col = color(c); col.setAlpha(64); return col; }); sel = createSelect(); sel.position(10, 10); sel.option(&amp;#39;BLEND&amp;#39;); sel.option(&amp;#39;SCREEN&amp;#39;); sel.option(&amp;#39;SOFT_LIGHT&amp;#39;); sel.changed(() =&amp;gt; { const val = sel.value(); if (val === &amp;#39;BLEND&amp;#39;) curBlendMode = BLEND; else if (val === &amp;#39;SCREEN&amp;#39;) curBlendMode = SCREEN; else if (val === &amp;#39;SOFT_LIGHT&amp;#39;) curBlendMode = SOFT_LIGHT; else curBlendMode = BLEND; redraw(); }); curBlendMode = BLEND; redraw(); noLoop(); } function draw() { clear(); blendMode(curBlendMode); noStroke(); translate(0, height/2); push(); translate(width/4, 0); fill(palette[0]); for (let i = 0; i &amp;lt; 10; i++) { drawShape(50, 3); } fill(palette[1]); translate(width/4, 0); for (let i = 0; i &amp;lt; 10; i++) { drawShape(50, 4); } fill(palette[2]); translate(width/4, 0); for (let i = 0; i &amp;lt; 10; i++) { drawShape(50, 5); } pop(); } const drawShape = (radius, rotNum) =&amp;gt; { beginShape(); for (let i = 0; i &amp;lt; rotNum; i++) { const ang1 = TWO_PI/rotNum * i; const ang2 = TWO_PI/rotNum * (i + 1); const x1 = radius * cos(ang1); const y1 = radius * sin(ang1); const x2 = radius * cos(ang2); const y2 = radius * sin(ang2); rec(createVector(x1, y1), createVector(x2, y2), 0); } endShape(CLOSE); } // Koch curve-like drawing const rec = (pos1, pos2, depth) =&amp;gt; { if (depth &amp;gt;= depthMax) { return; } const vorig = p5.</description></item><item><title>Good Night</title><link>https://bombrary.github.io/sketch/posts/good-night/</link><pubDate>Thu, 15 Dec 2022 18:41:41 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/good-night/</guid><description>別ページで閲覧 const iterMax = 10; const brushMax = 100; const circleMax = 20; let circles; let yellowBrushes, blueBrushes; let yellowPalette, bluePalette; let layerBg, layerFg; function setup() { createCanvas(windowWidth, windowHeight); blendMode(BLEND); noStroke(); yellowPalette = [&amp;#39;#f8b12f&amp;#39;, &amp;#39;#fae690&amp;#39;, &amp;#39;#f7fae8&amp;#39;].map((c) =&amp;gt; color(c)); bluePalette = [&amp;#39;#211a3a&amp;#39;, &amp;#39;#22458e&amp;#39;, &amp;#39;#63beed&amp;#39;].map((c) =&amp;gt; color(c)); layerBg = createGraphics(width, height); layerFg = createGraphics(width, height); background(bluePalette[0]); blueBrushes = createBrushes(bluePalette, layerFg); yellowBrushes = createBrushes(yellowPalette, layerBg); circles = Array.from({ length: circleMax }) .map(() =&amp;gt; new Circle(random(0, width), random(0, height) ,random(10, 100))); } function draw() { for (let i = 0; i &amp;lt; iterMax; i++) { blueBrushes.</description></item><item><title>Chocolate Box</title><link>https://bombrary.github.io/sketch/posts/chocolate-box/</link><pubDate>Wed, 14 Dec 2022 16:58:38 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/chocolate-box/</guid><description>別ページで閲覧 let palette; const frameMax = 200; let frame = 0; function setup() { createCanvas(windowWidth, windowHeight); palette = [&amp;#39;#A77979&amp;#39;, &amp;#39;#553939&amp;#39;, &amp;#39;#704F4F&amp;#39;].map((c) =&amp;gt; color(c)); background(&amp;#39;#472D2D&amp;#39;); } function draw() { noStroke(); const rectNum = 5; const lenMax = min(width, height)/2; const rectLen = lenMax / rectNum; const xsp = (width - rectLen * rectNum * 2)/2; const ysp = (height - rectLen * rectNum * 2)/2; push(); stroke(&amp;#39;red&amp;#39;); pop(); if (frame &amp;lt; frameMax) { fillUp(xsp, ysp, rectNum, rectNum, rectLen, [1/2]); fillUp(xsp + rectNum*rectLen, ysp, rectNum, rectNum, rectLen, [1/3, 2/3]); fillUp(xsp, ysp + rectNum*rectLen, rectNum, rectNum, rectLen, [1/4, 2/4, 3/4]); fillUp(xsp + rectNum*rectLen, ysp + rectNum*rectLen, rectNum, rectNum, rectLen, [1/5, 2/5, 3/5, 4/5]); frame++; } else { noLoop(); } } const fillUp = (xstart, ystart, row, col, rectLen, ratioArr) =&amp;gt; { const w = rectLen; const h = rectLen; for (let i = 0; i &amp;lt; row; i++) { for (let j = 0; j &amp;lt; col; j++) { const x = xstart + j * rectLen; const y = ystart + i * rectLen; const [t0, t1, t2] = [random(ratioArr), random(ratioArr), random(ratioArr)]; const num = random(4); fill(randomColor(palette)); if (num &amp;lt; 1) { triangle(x + t0*w, y, x, y + t1*h, x + w, y + t2*h); } else if (num &amp;lt; 2) { triangle(x + t0*w, y, x, y + t1*h, x + t2*w, y + h); } else if (num &amp;lt; 3) { triangle(x + t0*w, y, x + w, y + t2*h, x + t2*w, y + h); } else { triangle(x + t2*w, y + h, x, y + t1*h, x + w, y + t2*h); } } } } const randomColor = (palette) =&amp;gt; { const t = random(palette.</description></item><item><title>A Blue Light</title><link>https://bombrary.github.io/sketch/posts/a-blue-light/</link><pubDate>Tue, 13 Dec 2022 12:52:14 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/a-blue-light/</guid><description>別ページで閲覧 let yellowPalette, bluePalette, bluePaletteRGB; let grainImg; let socket, light, code; let sizeScale; function setup() { createCanvas(windowWidth, windowHeight); yellowPalette = [&amp;#39;rgb(248,177,47)&amp;#39;, &amp;#39;rgb(250,230,144)&amp;#39;, &amp;#39;rgb(247,250,232)&amp;#39;].map((c) =&amp;gt; color(c)); bluePalette = [&amp;#39;rgb(33,26,58)&amp;#39;, &amp;#39;rgb(34,69,142)&amp;#39;, &amp;#39;rgb(99,190,237)&amp;#39;].map((c) =&amp;gt; color(c)); bluePaletteRGB = bluePalette.map((c) =&amp;gt; [red(c), green(c), blue(c)]); grainImg = generateGrainImg(); sizeScale = min(width, height)/150; socket = new Socket(sizeScale); light = new Light(sizeScale); code = new Code(5*sizeScale, 50*sizeScale, 5*sizeScale); } function draw() { background(bluePalette[0]); push(); translate(width/2, 0); push(); translate(0, code.</description></item><item><title>Toy Box</title><link>https://bombrary.github.io/sketch/posts/toy-box/</link><pubDate>Mon, 12 Dec 2022 20:09:07 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/toy-box/</guid><description> 別ページで閲覧 let palette; function setup() { createCanvas(windowWidth, windowHeight); palette = [&amp;#39;#FF9E9E&amp;#39;, &amp;#39;#F8F988&amp;#39;, &amp;#39;#C0EEE4&amp;#39;]; background(&amp;#39;#F9F9F9&amp;#39;); rec(0, 0, width, height, 0) } const rec = (x, y, w, h, depth) =&amp;gt; { if (w &amp;lt; width/10 || h &amp;lt; height/10) { noStroke(); fill(random(palette)); push(); translate(x, y); translate(-w/2, -h/2); rotate(random(-PI/90, PI/90)); translate(w/2, h/2); rect(0, 0, w, h); pop(); } else { const t = random(); if (random() &amp;lt; 0.5) { [newW, newH] = [t*w, h] rec(x + t*w, y, (1-t)*w, h, depth + 1); rec(x , y, t*w, h, depth + 1); } else { [newW, newH] = [w, t*h] rec(x, y + t*h, w, (1-t)*h, depth + 1); rec(x, y , w, t*h, depth + 1); } } }</description></item><item><title>Flicker</title><link>https://bombrary.github.io/sketch/posts/flicker/</link><pubDate>Sun, 11 Dec 2022 16:17:40 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/flicker/</guid><description>別ページで閲覧 let img, gridCircles; let lightColorBase; function setup() { createCanvas(windowWidth, windowHeight); img = noiseOverlay(); push(); colorMode(HSB); lightColorBase = color(&amp;#39;#FFFFD0&amp;#39;); pop(); const [N, M] = [3, 3]; const r = 10; const sep = 2; const [rectHeight, rectWidth] = [2*r*N, 2*r*M]; const rectSep = 40; const rectRowNum = ceil(height / (rectHeight + rectSep)); const rectColNum = ceil(width / (rectWidth + rectSep)); const rectNum = 30; const rectNumMax = rectRowNum * rectColNum; const indicies = choice(Array.</description></item><item><title>Colorful</title><link>https://bombrary.github.io/sketch/posts/colorful/</link><pubDate>Sat, 10 Dec 2022 11:44:39 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/colorful/</guid><description>別ページで閲覧 const alphabet = &amp;#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890&amp;#39;.split(&amp;#39;&amp;#39;); const rNum = 10; let textNumMin, textNumMax; let textSizeMin, textSizeMax; function setup() { createCanvas(windowWidth, windowHeight); palette = [&amp;#39;rgb(238,217,64)&amp;#39;, &amp;#39;rgb(229,100,37)&amp;#39;, &amp;#39;rgb(241,183,209)&amp;#39;, &amp;#39;rgb(163,221,231)&amp;#39;, &amp;#39;rgb(167, 202, 102)&amp;#39;].map((c) =&amp;gt; color(c)); background(255); const rMax = max(width/2, height/2); [textNumMin, textNumMax] = [rMax/2.5, rMax/1.5]; [textSizeMin, textSizeMax] = [rMax/30, rMax/10]; const rSep = rMax / rNum; for (let i = 0; i &amp;lt; rNum; i++) { if (i % 2 == 0) { const img = createGraphics(width, height); img.</description></item><item><title>Convergence</title><link>https://bombrary.github.io/sketch/posts/convergence/</link><pubDate>Fri, 09 Dec 2022 18:51:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/convergence/</guid><description>別ページで閲覧 const rectSep = 10; const rectNum = 40; const tileNum = 50; const tileSep = 2; function setup() { cvs = createCanvas(windowWidth, windowHeight); const palette1 = [&amp;#39;#E97777&amp;#39;, &amp;#39;#FF9F9F&amp;#39;, &amp;#39;#FFACC7&amp;#39;].map((c) =&amp;gt; color(c)); const palette2 = [&amp;#39;#FCDDB0&amp;#39;, &amp;#39;#FFFAD7&amp;#39;, &amp;#39;#FFB9B9&amp;#39;, &amp;#39;#FFDDD2&amp;#39;].map((c) =&amp;gt; color(c)); push(); drawingContext.shadowBlur = 10; drawingContext.shadowColor = &amp;#39;black&amp;#39;; const tileLen = width / tileNum; for (let i = 0; i &amp;lt; ceil(width/tileLen); i++) { for (let j = 0; j &amp;lt; ceil(height/tileLen); j++) { const x = (tileLen + tileSep) * i; const y = (tileLen + tileSep) * j; noStroke(); fill(random(palette2)); rect(x, y, tileLen, tileLen); } } pop(); background(255,255,255,64); const rectWidth = width / rectNum - rectSep; const img = createGraphics(width, height); for (let i = 0; i &amp;lt; rectNum; i++) { const x = (rectWidth + rectSep) * i; const t = i / rectNum; const rectHeight = 1.</description></item><item><title>Snow</title><link>https://bombrary.github.io/sketch/posts/snow/</link><pubDate>Thu, 08 Dec 2022 11:31:42 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/snow/</guid><description>別ページで閲覧 let cvs; let palette; const depthMax = 7; function setup() { cvs = createCanvas(windowWidth, windowHeight); palette = [&amp;#39;#CFF5E7&amp;#39;, &amp;#39;#A0E4CB&amp;#39;, &amp;#39;#59C1BD&amp;#39;, &amp;#39;#0D4C92&amp;#39;].map((c) =&amp;gt; color(c)); const bgColor = &amp;#39;#EFF5F5&amp;#39;; background(bgColor); noFill(); stroke(0); const L = min(width, height)/2; const img = createGraphics(width, height); img.translate(width/2, height/2); rec(img, createVector(0, -L/sqrt(3)), createVector(L/2, L/sqrt(3)/2), createVector(-L/2, L/sqrt(3)/2), 0); drawingContext.shadowBlur = 50; drawingContext.shadowColor = &amp;#39;gray&amp;#39;; drawingContext.shadowOffsetX = 10; drawingContext.shadowOffsetY = 10; image(img, 0, 0); } const rec = (img, p1, p2, p3, depth) =&amp;gt; { if (depth &amp;lt; depthMax) { img.</description></item><item><title>Planet</title><link>https://bombrary.github.io/sketch/posts/planet/</link><pubDate>Wed, 07 Dec 2022 10:10:27 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/planet/</guid><description>別ページで閲覧 let palette, cvs; let donutImgs; let RMax; const RNum = 5; const period = 40; function setup() { cvs = createCanvas(windowWidth, windowHeight); palette = [&amp;#39;#181D27&amp;#39;, &amp;#39;#254D32&amp;#39;, &amp;#39;#3A7D44&amp;#39;, &amp;#39;#69B578&amp;#39;, &amp;#39;#D0DB97&amp;#39;].map((c) =&amp;gt; color(c)); RMax = min(width, height) / 2; const rectLen = min(width, height) / 3 * 2; strokeWeight(10); noFill(); rectMode(CENTER); [rectLen*sqrt(2), rectLen, rectLen/3*2, rectLen/2].forEach((len) =&amp;gt; { stroke(lerpColor(palette[0], palette[2], random(0, 1))); rect(width / 2, height / 2, len, len); }); stroke(palette[2]); textAlign(CENTER, CENTER); textSize(100); text(&amp;#34;Hello&amp;#34;, width/2, height/2); const sep = Math.</description></item><item><title>Plant</title><link>https://bombrary.github.io/sketch/posts/plant/</link><pubDate>Tue, 06 Dec 2022 10:12:37 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/plant/</guid><description>別ページで閲覧 let tree, palette; const depthMax = 5; const flowerRadius = 7.5; const nodeMass = 1; const coefRestore = 0.01; const coefAir = 0.01; const windMax = 0.002; const windPeriod = 1000; const randomForceVar = 0.0005; let branchLenMean, branchLenStd; let branchAngleMean, branchAngleStd; function setup() { createCanvas(windowWidth, windowHeight); palette = [&amp;#39;#F4EAD5&amp;#39;, &amp;#39;#CCD6A6&amp;#39;, &amp;#39;#FF9E9E&amp;#39;].map((c) =&amp;gt; color(c)); [branchAngleMean, branchAngleStd] = [PI/6, 0.01]; [branchLenMean, branchLenStd] = [height / depthMax - (10 * depthMax), 20]; iterMax = height; tree = new Tree(createVector(0, -1), randomGaussian(branchLenMean, branchLenStd), 0, depthMax); } function draw() { background(palette[0]); const t = deltaTime * frameCount; const windX = windMax*sin(t/windPeriod); tree.</description></item><item><title>Glitchy Sun</title><link>https://bombrary.github.io/sketch/posts/glitchy-sun/</link><pubDate>Mon, 05 Dec 2022 11:27:30 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/glitchy-sun/</guid><description>別ページで閲覧 let palette, cvs; const [wMin, wMax] = [10, 500]; const [hMin, hMax] = [10, 500]; function setup() { palette = [&amp;#39;#E8F3D6&amp;#39;, &amp;#39;#FCF9BE&amp;#39;, &amp;#39;#FFDCA9&amp;#39;, &amp;#39;#FAAB78&amp;#39;].map((c) =&amp;gt; color(c)); cvs = createCanvas(windowWidth, windowHeight); background(palette[1]); const img = createGraphics(width, height); img.noStroke(); img.fill(palette[3]); img.circle(width / 2, height / 2, min(width, height)); blendMode(MULTIPLY); for (let i = 0; i &amp;lt; 50; i++) { const r = random(0, max(width, height)); const stAngle = random(0, TWO_PI); const enAngle = random(0, TWO_PI); const weight = random(0, 20); stroke(lerpColor(palette[1], palette[3], random())); strokeWeight(weight); noFill() arc(width / 4, height / 4, r, r, stAngle, enAngle); arc(3*width / 4, 3*height / 4, r, r, stAngle, enAngle); img.</description></item><item><title>Dance Room</title><link>https://bombrary.github.io/sketch/posts/dance-room/</link><pubDate>Sun, 04 Dec 2022 10:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/dance-room/</guid><description>別ページで閲覧 let cols; let N, M; let R, r; function setup() { createCanvas(windowWidth, windowHeight); cols = [color(&amp;#39;rgb(23, 10, 39)&amp;#39;), color(&amp;#39;rgb(111, 89, 163)&amp;#39;), color(&amp;#39;rgb(255, 255, 255)&amp;#39;)] frameRate(10); blendMode(BLEND); R = 50; r = 20; N = Math.floor(height / R); M = Math.floor(width / R); noiseDetail(8, 0.65); noStroke(); } function draw() { background(cols[0]); for (let i = 0; i &amp;lt; N; i++) { for (let j = 0; j &amp;lt; M; j++) { const [x, y] = hexCoordinate(i, j); const rate = noise(x, y, frameCount); colorMode(RGB); const col = lerpColor3(cols[0], cols[1], cols[2], rate); fill(col); const val = rate*20; colorMode(HSB, 360, 100, 100); drawingContext.</description></item><item><title>Night City</title><link>https://bombrary.github.io/sketch/posts/night-city/</link><pubDate>Sat, 03 Dec 2022 07:00:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/night-city/</guid><description>別ページで閲覧 const cols = [&amp;#39;#001F3F&amp;#39;, &amp;#39;#083358&amp;#39;, &amp;#39;#0D63A5&amp;#39;, &amp;#39;#FFD717&amp;#39;]; const colsRedundant = [...new Array(8).fill(cols[0]), ...new Array(4).fill(cols[1]), ...new Array(2).fill(cols[2]), ...new Array(1).fill(cols[3])]; const dt = 1; function setup() { createCanvas(windowWidth, windowHeight); background(cols[0]); noStroke(); for (let i = 0; i &amp;lt; 1000; i++) { const p1 = createVector(random(0, width), random(0, height)); const p2 = createVector(width / 2, height / 2); const vec = p5.Vector.sub(p2, p1).mult(random(0, 0.5)); band(p1, vec, abs(randomGaussian(0, 10))); } } const band = (pos, vec, w) =&amp;gt; { const norm = p5.</description></item><item><title>Sea of Characters</title><link>https://bombrary.github.io/sketch/posts/sea-of-characters/</link><pubDate>Fri, 02 Dec 2022 11:35:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/sea-of-characters/</guid><description>別ページで閲覧 let entities; const [fontSizeMin, fontSizeMax] = [0, 100]; const [rMin, rMax] = [0, 100]; const [textDxMin, textDxMax] = [-50, 50]; const [textDyMin, textDyMax] = [-1, 0]; const [circleDxMin, circleDxMax] = [-0.5, 0.5]; const [circleDyMin, circleDyMax] = [-1, 0]; function setup() { createCanvas(windowWidth, windowHeight); smooth(); entities = [...createTexts(20), ...createCircles(20)]; } function draw() { background(&amp;#39;#181B39&amp;#39;); for (const e of entities) { e.move(); e.draw(); } } const createCircles = (n) =&amp;gt; Array.</description></item><item><title>Circular Bars</title><link>https://bombrary.github.io/sketch/posts/circular-bars/</link><pubDate>Thu, 01 Dec 2022 11:25:00 +0900</pubDate><guid>https://bombrary.github.io/sketch/posts/circular-bars/</guid><description>別ページで閲覧 let r = 800; const dr = 100; const barMax = 100; const N = 400; let sep; function setup() { sep = TWO_PI / N; createCanvas(windowWidth, windowHeight); background(&amp;#39;#005b98&amp;#39;); } function draw() { translate(width / 2, height / 2); if (r &amp;lt;= 0) { noStroke(); fill(&amp;#39;white&amp;#39;); ellipse(0, 0, 2*dr, 2*dr); return; } const bars = createRandomBar(N, 0, barMax); let theta = 0; bars.forEach((bar) =&amp;gt; { fill(255); stroke(&amp;#39;orange&amp;#39;); drawBar(r, theta, sep, bar); theta += sep; }); r -= dr; } const drawBar = (r, theta, sep, bar) =&amp;gt; { const vs_polar = [ [r, theta], [r + bar, theta], [r + bar, theta + sep], [r, theta + sep], ] beginShape(); vs_polar.</description></item></channel></rss>